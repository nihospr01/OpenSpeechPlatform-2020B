{"ast":null,"code":"export default function (d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n}\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {\n    data: d\n  },\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j; // If the tree is empty, initialize the root as a leaf.\n\n  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.\n\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  } // Is the new point is exactly coincident with the existing point?\n\n\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.\n\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));\n\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d,\n      i,\n      n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity; // Compute the points and their extent.\n\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  } // If there were no (valid) points, abort.\n\n\n  if (x0 > x1 || y0 > y1) return this; // Expand the tree to cover the new points.\n\n  this.cover(x0, y0).cover(x1, y1); // Add the new points.\n\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-quadtree/src/add.js"],"names":["d","x","_x","call","y","_y","add","cover","tree","isNaN","parent","node","_root","leaf","data","x0","_x0","y0","_y0","x1","_x1","y1","_y1","xm","ym","xp","yp","right","bottom","i","j","length","next","Array","addAll","n","xz","yz","Infinity"],"mappings":"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","sourcesContent":["export default function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n}\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, abort.\n  if (x0 > x1 || y0 > y1) return this;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}