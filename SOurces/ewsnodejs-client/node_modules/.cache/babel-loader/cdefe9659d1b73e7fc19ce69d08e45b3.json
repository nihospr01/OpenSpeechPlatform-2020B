{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n'use strict';\n\nvar invariant = require('./invariant'); // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\n\n\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\n\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\n\n\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n\n  if (index + 1 === str.length) {\n    return false;\n  }\n\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\n\n\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\n\n\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\n\n\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n\n  var len = 0;\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n\n  return len;\n}\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\n\n\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0; // Call the native functions if there's no surrogate char\n\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  } // Obvious cases\n\n\n  var size = str.length;\n\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  } // Find the actual starting position\n\n\n  var posA = 0;\n\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n\n    if (posA < 0) {\n      posA = 0;\n    }\n  } // Find the actual ending position\n\n\n  var posB = size;\n\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n\n  return str.substring(posA, posB);\n}\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\n\n\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n\n  if (start < 0) {\n    start = 0;\n  }\n\n  if (end < 0) {\n    end = 0;\n  }\n\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\n\n\nfunction getCodePoints(str) {\n  var codePoints = [];\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n\n  return codePoints;\n}\n\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\nmodule.exports = UnicodeUtils;","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/fbjs/lib/UnicodeUtils.js"],"names":["invariant","require","SURROGATE_HIGH_START","SURROGATE_HIGH_END","SURROGATE_LOW_START","SURROGATE_LOW_END","SURROGATE_UNITS_REGEX","isCodeUnitInSurrogateRange","codeUnit","isSurrogatePair","str","index","length","process","env","NODE_ENV","first","charCodeAt","second","hasSurrogateUnit","test","getUTF16Length","pos","strlen","len","substr","start","undefined","Infinity","size","posA","posB","substring","end","Math","abs","getCodePoints","codePoints","push","codePointAt","UnicodeUtils","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,aAAD,CAAvB,C,CAEA;AACA;;;AACA,IAAIC,oBAAoB,GAAG,MAA3B;AACA,IAAIC,kBAAkB,GAAG,MAAzB;AACA,IAAIC,mBAAmB,GAAG,MAA1B;AACA,IAAIC,iBAAiB,GAAG,MAAxB;AACA,IAAIC,qBAAqB,GAAG,iBAA5B;AAEA;AACA;AACA;AACA;;AACA,SAASC,0BAAT,CAAoCC,QAApC,EAA8C;AAC5C,SAAON,oBAAoB,IAAIM,QAAxB,IAAoCA,QAAQ,IAAIH,iBAAvD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,eAAT,CAAyBC,GAAzB,EAA8BC,KAA9B,EAAqC;AACnC,IAAE,KAAKA,KAAL,IAAcA,KAAK,GAAGD,GAAG,CAACE,MAA5B,IAAsCC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCf,SAAS,CAAC,KAAD,EAAQ,yDAAR,EAAmEW,KAAnE,EAA0ED,GAAG,CAACE,MAA9E,CAAjD,GAAyIZ,SAAS,CAAC,KAAD,CAAxL,GAAkM,KAAK,CAAvM;;AACA,MAAIW,KAAK,GAAG,CAAR,KAAcD,GAAG,CAACE,MAAtB,EAA8B;AAC5B,WAAO,KAAP;AACD;;AACD,MAAII,KAAK,GAAGN,GAAG,CAACO,UAAJ,CAAeN,KAAf,CAAZ;AACA,MAAIO,MAAM,GAAGR,GAAG,CAACO,UAAJ,CAAeN,KAAK,GAAG,CAAvB,CAAb;AACA,SAAOT,oBAAoB,IAAIc,KAAxB,IAAiCA,KAAK,IAAIb,kBAA1C,IAAgEC,mBAAmB,IAAIc,MAAvF,IAAiGA,MAAM,IAAIb,iBAAlH;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASc,gBAAT,CAA0BT,GAA1B,EAA+B;AAC7B,SAAOJ,qBAAqB,CAACc,IAAtB,CAA2BV,GAA3B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,cAAT,CAAwBX,GAAxB,EAA6BY,GAA7B,EAAkC;AAChC,SAAO,IAAIf,0BAA0B,CAACG,GAAG,CAACO,UAAJ,CAAeK,GAAf,CAAD,CAArC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAgBb,GAAhB,EAAqB;AACnB;AACA,MAAI,CAACS,gBAAgB,CAACT,GAAD,CAArB,EAA4B;AAC1B,WAAOA,GAAG,CAACE,MAAX;AACD;;AAED,MAAIY,GAAG,GAAG,CAAV;;AACA,OAAK,IAAIF,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGZ,GAAG,CAACE,MAA5B,EAAoCU,GAAG,IAAID,cAAc,CAACX,GAAD,EAAMY,GAAN,CAAzD,EAAqE;AACnEE,IAAAA,GAAG;AACJ;;AACD,SAAOA,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAgBf,GAAhB,EAAqBgB,KAArB,EAA4Bd,MAA5B,EAAoC;AAClCc,EAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACAd,EAAAA,MAAM,GAAGA,MAAM,KAAKe,SAAX,GAAuBC,QAAvB,GAAkChB,MAAM,IAAI,CAArD,CAFkC,CAIlC;;AACA,MAAI,CAACO,gBAAgB,CAACT,GAAD,CAArB,EAA4B;AAC1B,WAAOA,GAAG,CAACe,MAAJ,CAAWC,KAAX,EAAkBd,MAAlB,CAAP;AACD,GAPiC,CASlC;;;AACA,MAAIiB,IAAI,GAAGnB,GAAG,CAACE,MAAf;;AACA,MAAIiB,IAAI,IAAI,CAAR,IAAaH,KAAK,GAAGG,IAArB,IAA6BjB,MAAM,IAAI,CAA3C,EAA8C;AAC5C,WAAO,EAAP;AACD,GAbiC,CAelC;;;AACA,MAAIkB,IAAI,GAAG,CAAX;;AACA,MAAIJ,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOA,KAAK,GAAG,CAAR,IAAaI,IAAI,GAAGD,IAA3B,EAAiCH,KAAK,EAAtC,EAA0C;AACxCI,MAAAA,IAAI,IAAIT,cAAc,CAACX,GAAD,EAAMoB,IAAN,CAAtB;AACD;;AACD,QAAIA,IAAI,IAAID,IAAZ,EAAkB;AAChB,aAAO,EAAP;AACD;AACF,GAPD,MAOO,IAAIH,KAAK,GAAG,CAAZ,EAAe;AACpB,SAAKI,IAAI,GAAGD,IAAZ,EAAkBH,KAAK,GAAG,CAAR,IAAa,IAAII,IAAnC,EAAyCJ,KAAK,EAA9C,EAAkD;AAChDI,MAAAA,IAAI,IAAIT,cAAc,CAACX,GAAD,EAAMoB,IAAI,GAAG,CAAb,CAAtB;AACD;;AACD,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZA,MAAAA,IAAI,GAAG,CAAP;AACD;AACF,GA/BiC,CAiClC;;;AACA,MAAIC,IAAI,GAAGF,IAAX;;AACA,MAAIjB,MAAM,GAAGiB,IAAb,EAAmB;AACjB,SAAKE,IAAI,GAAGD,IAAZ,EAAkBlB,MAAM,GAAG,CAAT,IAAcmB,IAAI,GAAGF,IAAvC,EAA6CjB,MAAM,EAAnD,EAAuD;AACrDmB,MAAAA,IAAI,IAAIV,cAAc,CAACX,GAAD,EAAMqB,IAAN,CAAtB;AACD;AACF;;AAED,SAAOrB,GAAG,CAACsB,SAAJ,CAAcF,IAAd,EAAoBC,IAApB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,CAAmBtB,GAAnB,EAAwBgB,KAAxB,EAA+BO,GAA/B,EAAoC;AAClCP,EAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACAO,EAAAA,GAAG,GAAGA,GAAG,KAAKN,SAAR,GAAoBC,QAApB,GAA+BK,GAAG,IAAI,CAA5C;;AAEA,MAAIP,KAAK,GAAG,CAAZ,EAAe;AACbA,IAAAA,KAAK,GAAG,CAAR;AACD;;AACD,MAAIO,GAAG,GAAG,CAAV,EAAa;AACXA,IAAAA,GAAG,GAAG,CAAN;AACD;;AAED,MAAIrB,MAAM,GAAGsB,IAAI,CAACC,GAAL,CAASF,GAAG,GAAGP,KAAf,CAAb;AACAA,EAAAA,KAAK,GAAGA,KAAK,GAAGO,GAAR,GAAcP,KAAd,GAAsBO,GAA9B;AACA,SAAOR,MAAM,CAACf,GAAD,EAAMgB,KAAN,EAAad,MAAb,CAAb;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwB,aAAT,CAAuB1B,GAAvB,EAA4B;AAC1B,MAAI2B,UAAU,GAAG,EAAjB;;AACA,OAAK,IAAIf,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGZ,GAAG,CAACE,MAA5B,EAAoCU,GAAG,IAAID,cAAc,CAACX,GAAD,EAAMY,GAAN,CAAzD,EAAqE;AACnEe,IAAAA,UAAU,CAACC,IAAX,CAAgB5B,GAAG,CAAC6B,WAAJ,CAAgBjB,GAAhB,CAAhB;AACD;;AACD,SAAOe,UAAP;AACD;;AAED,IAAIG,YAAY,GAAG;AACjBJ,EAAAA,aAAa,EAAEA,aADE;AAEjBf,EAAAA,cAAc,EAAEA,cAFC;AAGjBF,EAAAA,gBAAgB,EAAEA,gBAHD;AAIjBZ,EAAAA,0BAA0B,EAAEA,0BAJX;AAKjBE,EAAAA,eAAe,EAAEA,eALA;AAMjBc,EAAAA,MAAM,EAAEA,MANS;AAOjBS,EAAAA,SAAS,EAAEA,SAPM;AAQjBP,EAAAA,MAAM,EAAEA;AARS,CAAnB;AAWAgB,MAAM,CAACC,OAAP,GAAiBF,YAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n\n'use strict';\n\nvar invariant = require('./invariant');\n\n// These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n  if (index + 1 === str.length) {\n    return false;\n  }\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n\n  var len = 0;\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n  return len;\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0;\n\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  }\n\n  // Obvious cases\n  var size = str.length;\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  }\n\n  // Find the actual starting position\n  var posA = 0;\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n    if (posA < 0) {\n      posA = 0;\n    }\n  }\n\n  // Find the actual ending position\n  var posB = size;\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n\n  return str.substring(posA, posB);\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\nfunction getCodePoints(str) {\n  var codePoints = [];\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n  return codePoints;\n}\n\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\n\nmodule.exports = UnicodeUtils;"]},"metadata":{},"sourceType":"script"}