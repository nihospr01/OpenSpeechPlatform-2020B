{"ast":null,"code":"import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { epsilon, halfPi } from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start) {\n  return function (sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function polygonEnd() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function sphere() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i,\n          n = ringSegments.length,\n          m,\n          segment,\n          point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return; // No intersections.\n\n      if (clean & 1) {\n        segment = ringSegments[0];\n\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n\n          for (i = 0; i < m; ++i) {\n            sink.point((point = segment[i])[0], point[1]);\n          }\n\n          sink.lineEnd();\n        }\n\n        return;\n      } // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n\n\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n} // Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\n\n\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-geo/src/clip/index.js"],"names":["clipBuffer","clipRejoin","epsilon","halfPi","polygonContains","merge","pointVisible","clipLine","interpolate","start","sink","line","ringBuffer","ringSink","polygonStarted","polygon","segments","ring","clip","point","lineStart","lineEnd","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","startInside","length","compareIntersection","sphere","lambda","phi","pointLine","push","clean","ringSegments","result","i","n","m","segment","pop","concat","shift","filter","validSegment","a","b","x"],"mappings":"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","sourcesContent":["import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {epsilon, halfPi} from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n"]},"metadata":{},"sourceType":"module"}