{"ast":null,"code":"import { bisect } from \"d3-array\";\nimport { interpolate as interpolateValue, interpolateNumber, interpolateRound } from \"d3-interpolate\";\nimport { map, slice } from \"./array\";\nimport constant from \"./constant\";\nimport number from \"./number\";\nvar unit = [0, 1];\nexport function identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= a = +a) ? function (x) {\n    return (x - a) / b;\n  } : constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0],\n      b = domain[domain.length - 1],\n      t;\n  if (a > b) t = a, a = b, b = t;\n  return function (x) {\n    return Math.max(a, Math.min(b, x));\n  };\n} // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\n\n\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0],\n      d1 = domain[1],\n      r0 = range[0],\n      r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function (x) {\n    return r0(d0(x));\n  };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1; // Reverse descending domains.\n\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function (x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nexport function copy(source, target) {\n  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());\n}\nexport function transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function (y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));\n  };\n\n  scale.domain = function (_) {\n    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function (_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function (_) {\n    return range = slice.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function (_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n\n  scale.interpolate = function (_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function (_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function (t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\nexport default function continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-scale/src/continuous.js"],"names":["bisect","interpolate","interpolateValue","interpolateNumber","interpolateRound","map","slice","constant","number","unit","identity","x","normalize","a","b","isNaN","NaN","clamper","domain","length","t","Math","max","min","bimap","range","d0","d1","r0","r1","polymap","j","d","Array","r","i","reverse","copy","source","target","clamp","unknown","transformer","transform","untransform","piecewise","output","input","rescale","scale","invert","y","_","arguments","call","rangeRound","u","continuous"],"mappings":"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","sourcesContent":["import {bisect} from \"d3-array\";\nimport {interpolate as interpolateValue, interpolateNumber, interpolateRound} from \"d3-interpolate\";\nimport {map, slice} from \"./array\";\nimport constant from \"./constant\";\nimport number from \"./number\";\n\nvar unit = [0, 1];\n\nexport function identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nexport function copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nexport function transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nexport default function continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n"]},"metadata":{},"sourceType":"module"}