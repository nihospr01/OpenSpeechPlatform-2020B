{"ast":null,"code":"import adder from \"./adder.js\";\nimport { areaStream, areaRingSum } from \"./area.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nimport { abs, degrees, epsilon, radians } from \"./math.js\";\nimport stream from \"./stream.js\";\nvar lambda0,\n    phi0,\n    lambda1,\n    phi1,\n    // bounds\nlambda2,\n    // previous lambda-coordinate\nlambda00,\n    phi00,\n    // first point\np0,\n    // previous 3D point\ndeltaSum = adder(),\n    ranges,\n    range;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function polygonStart() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function polygonEnd() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon) phi1 = 90;else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function sphere() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n} // Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\n\n\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function (feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream); // First, sort ranges by their minimum longitudes.\n\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.\n\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    } // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n\n\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-geo/src/bounds.js"],"names":["adder","areaStream","areaRingSum","cartesian","cartesianCross","cartesianNormalizeInPlace","spherical","abs","degrees","epsilon","radians","stream","lambda0","phi0","lambda1","phi1","lambda2","lambda00","phi00","p0","deltaSum","ranges","range","boundsStream","point","boundsPoint","lineStart","boundsLineStart","lineEnd","boundsLineEnd","polygonStart","boundsRingPoint","boundsRingStart","boundsRingEnd","reset","polygonEnd","sphere","lambda","phi","push","linePoint","p","normal","equatorial","inflection","delta","sign","lambdai","phii","antimeridian","angle","add","rangeCompare","a","b","rangeContains","x","feature","i","n","merged","deltaMax","Infinity","length","sort","NaN"],"mappings":"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","sourcesContent":["import adder from \"./adder.js\";\nimport {areaStream, areaRingSum} from \"./area.js\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian.js\";\nimport {abs, degrees, epsilon, radians} from \"./math.js\";\nimport stream from \"./stream.js\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n"]},"metadata":{},"sourceType":"module"}