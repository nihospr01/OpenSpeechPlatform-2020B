{"ast":null,"code":"import { abs, epsilon } from \"../math.js\";\nimport clipBuffer from \"./buffer.js\";\nimport clipLine from \"./line.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { merge } from \"d3-array\";\nvar clipMax = 1e9,\n    clipMin = -clipMax; // TODO Use d3-polygonâ€™s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0,\n        a1 = 0;\n\n    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do {\n        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      } while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n  }\n\n  return function (stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__,\n        y__,\n        v__,\n        // first point\n    x_,\n        y_,\n        v_,\n        // previous point\n    first,\n        clean;\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n\n          if (a1 <= y1) {\n            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n          } else {\n            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n          }\n        }\n      }\n\n      return winding;\n    } // Buffer geometry within a polygon and then clip it en masse.\n\n\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n\n      if (cleanInside || visible) {\n        stream.polygonStart();\n\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n\n        stream.polygonEnd();\n      }\n\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    } // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n\n\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-geo/src/clip/rectangle.js"],"names":["abs","epsilon","clipBuffer","clipLine","clipRejoin","merge","clipMax","clipMin","clipRectangle","x0","y0","x1","y1","visible","x","y","interpolate","from","to","direction","stream","a","a1","corner","comparePoint","point","p","compareIntersection","b","ca","cb","activeStream","bufferStream","segments","polygon","ring","x__","y__","v__","x_","y_","v_","first","clean","clipStream","lineStart","lineEnd","polygonStart","polygonEnd","polygonInside","winding","i","n","length","j","m","a0","b0","b1","startInside","cleanInside","linePoint","push","NaN","rejoin","result","v","Math","max","min"],"mappings":"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","sourcesContent":["import {abs, epsilon} from \"../math.js\";\nimport clipBuffer from \"./buffer.js\";\nimport clipLine from \"./line.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygonâ€™s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}