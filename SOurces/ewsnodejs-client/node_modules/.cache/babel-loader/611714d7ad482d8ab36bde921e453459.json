{"ast":null,"code":"import cross from \"./cross.js\";\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n} // Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\n\n\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) {\n      --size;\n    }\n\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nexport default function (points) {\n  if ((n = points.length) < 3) return null;\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) {\n    sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  }\n\n  sortedPoints.sort(lexicographicOrder);\n\n  for (i = 0; i < n; ++i) {\n    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n  }\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.\n\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = []; // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n\n  for (i = upperIndexes.length - 1; i >= 0; --i) {\n    hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  }\n\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {\n    hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n  }\n\n  return hull;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-polygon/src/hull.js"],"names":["cross","lexicographicOrder","a","b","computeUpperHullIndexes","points","n","length","indexes","size","i","slice","sortedPoints","Array","flippedPoints","sort","upperIndexes","lowerIndexes","skipLeft","skipRight","hull","push"],"mappings":"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","sourcesContent":["import cross from \"./cross.js\";\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nexport default function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n}\n"]},"metadata":{},"sourceType":"module"}