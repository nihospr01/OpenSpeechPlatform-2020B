{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromDraftStateToRaw\n * @format\n * \n */\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar ContentBlock = require('./ContentBlock');\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar DraftStringKey = require('./DraftStringKey');\n\nvar encodeEntityRanges = require('./encodeEntityRanges');\n\nvar encodeInlineStyleRanges = require('./encodeInlineStyleRanges');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar createRawBlock = function createRawBlock(block, entityStorageMap) {\n  return {\n    key: block.getKey(),\n    text: block.getText(),\n    type: block.getType(),\n    depth: block.getDepth(),\n    inlineStyleRanges: encodeInlineStyleRanges(block),\n    entityRanges: encodeEntityRanges(block, entityStorageMap),\n    data: block.getData().toObject()\n  };\n};\n\nvar insertRawBlock = function insertRawBlock(block, entityMap, rawBlocks, blockCacheRef) {\n  if (block instanceof ContentBlock) {\n    rawBlocks.push(createRawBlock(block, entityMap));\n    return;\n  }\n\n  !(block instanceof ContentBlockNode) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'block is not a BlockNode') : invariant(false) : void 0;\n  var parentKey = block.getParentKey();\n\n  var rawBlock = blockCacheRef[block.getKey()] = _extends({}, createRawBlock(block, entityMap), {\n    children: []\n  });\n\n  if (parentKey) {\n    blockCacheRef[parentKey].children.push(rawBlock);\n    return;\n  }\n\n  rawBlocks.push(rawBlock);\n};\n\nvar encodeRawBlocks = function encodeRawBlocks(contentState, rawState) {\n  var entityMap = rawState.entityMap;\n  var rawBlocks = [];\n  var blockCacheRef = {};\n  var entityCacheRef = {};\n  var entityStorageKey = 0;\n  contentState.getBlockMap().forEach(function (block) {\n    block.findEntityRanges(function (character) {\n      return character.getEntity() !== null;\n    }, function (start) {\n      var entityKey = block.getEntityAt(start); // Stringify to maintain order of otherwise numeric keys.\n\n      var stringifiedEntityKey = DraftStringKey.stringify(entityKey); // This makes this function resilient to two entities\n      // erroneously having the same key\n\n      if (entityCacheRef[stringifiedEntityKey]) {\n        return;\n      }\n\n      entityCacheRef[stringifiedEntityKey] = entityKey; // we need the `any` casting here since this is a temporary state\n      // where we will later on flip the entity map and populate it with\n      // real entity, at this stage we just need to map back the entity\n      // key used by the BlockNode\n\n      entityMap[stringifiedEntityKey] = '' + entityStorageKey;\n      entityStorageKey++;\n    });\n    insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);\n  });\n  return {\n    blocks: rawBlocks,\n    entityMap: entityMap\n  };\n}; // Flip storage map so that our storage keys map to global\n// DraftEntity keys.\n\n\nvar encodeRawEntityMap = function encodeRawEntityMap(contentState, rawState) {\n  var blocks = rawState.blocks,\n      entityMap = rawState.entityMap;\n  var rawEntityMap = {};\n  Object.keys(entityMap).forEach(function (key, index) {\n    var entity = contentState.getEntity(DraftStringKey.unstringify(key));\n    rawEntityMap[index] = {\n      type: entity.getType(),\n      mutability: entity.getMutability(),\n      data: entity.getData()\n    };\n  });\n  return {\n    blocks: blocks,\n    entityMap: rawEntityMap\n  };\n};\n\nvar convertFromDraftStateToRaw = function convertFromDraftStateToRaw(contentState) {\n  var rawDraftContentState = {\n    entityMap: {},\n    blocks: []\n  }; // add blocks\n\n  rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState); // add entities\n\n  rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);\n  return rawDraftContentState;\n};\n\nmodule.exports = convertFromDraftStateToRaw;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/convertFromDraftStateToRaw.js"],"names":["_assign","require","_extends","target","i","arguments","length","source","key","Object","prototype","hasOwnProperty","call","ContentBlock","ContentBlockNode","DraftStringKey","encodeEntityRanges","encodeInlineStyleRanges","invariant","createRawBlock","block","entityStorageMap","getKey","text","getText","type","getType","depth","getDepth","inlineStyleRanges","entityRanges","data","getData","toObject","insertRawBlock","entityMap","rawBlocks","blockCacheRef","push","process","env","NODE_ENV","parentKey","getParentKey","rawBlock","children","encodeRawBlocks","contentState","rawState","entityCacheRef","entityStorageKey","getBlockMap","forEach","findEntityRanges","character","getEntity","start","entityKey","getEntityAt","stringifiedEntityKey","stringify","blocks","encodeRawEntityMap","rawEntityMap","keys","index","entity","unstringify","mutability","getMutability","convertFromDraftStateToRaw","rawDraftContentState","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromDraftStateToRaw\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar DraftStringKey = require('./DraftStringKey');\n\nvar encodeEntityRanges = require('./encodeEntityRanges');\nvar encodeInlineStyleRanges = require('./encodeInlineStyleRanges');\nvar invariant = require('fbjs/lib/invariant');\n\nvar createRawBlock = function createRawBlock(block, entityStorageMap) {\n  return {\n    key: block.getKey(),\n    text: block.getText(),\n    type: block.getType(),\n    depth: block.getDepth(),\n    inlineStyleRanges: encodeInlineStyleRanges(block),\n    entityRanges: encodeEntityRanges(block, entityStorageMap),\n    data: block.getData().toObject()\n  };\n};\n\nvar insertRawBlock = function insertRawBlock(block, entityMap, rawBlocks, blockCacheRef) {\n  if (block instanceof ContentBlock) {\n    rawBlocks.push(createRawBlock(block, entityMap));\n    return;\n  }\n\n  !(block instanceof ContentBlockNode) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'block is not a BlockNode') : invariant(false) : void 0;\n\n  var parentKey = block.getParentKey();\n  var rawBlock = blockCacheRef[block.getKey()] = _extends({}, createRawBlock(block, entityMap), {\n    children: []\n  });\n\n  if (parentKey) {\n    blockCacheRef[parentKey].children.push(rawBlock);\n    return;\n  }\n\n  rawBlocks.push(rawBlock);\n};\n\nvar encodeRawBlocks = function encodeRawBlocks(contentState, rawState) {\n  var entityMap = rawState.entityMap;\n\n\n  var rawBlocks = [];\n\n  var blockCacheRef = {};\n  var entityCacheRef = {};\n  var entityStorageKey = 0;\n\n  contentState.getBlockMap().forEach(function (block) {\n    block.findEntityRanges(function (character) {\n      return character.getEntity() !== null;\n    }, function (start) {\n      var entityKey = block.getEntityAt(start);\n      // Stringify to maintain order of otherwise numeric keys.\n      var stringifiedEntityKey = DraftStringKey.stringify(entityKey);\n      // This makes this function resilient to two entities\n      // erroneously having the same key\n      if (entityCacheRef[stringifiedEntityKey]) {\n        return;\n      }\n      entityCacheRef[stringifiedEntityKey] = entityKey;\n      // we need the `any` casting here since this is a temporary state\n      // where we will later on flip the entity map and populate it with\n      // real entity, at this stage we just need to map back the entity\n      // key used by the BlockNode\n      entityMap[stringifiedEntityKey] = '' + entityStorageKey;\n      entityStorageKey++;\n    });\n\n    insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);\n  });\n\n  return {\n    blocks: rawBlocks,\n    entityMap: entityMap\n  };\n};\n\n// Flip storage map so that our storage keys map to global\n// DraftEntity keys.\nvar encodeRawEntityMap = function encodeRawEntityMap(contentState, rawState) {\n  var blocks = rawState.blocks,\n      entityMap = rawState.entityMap;\n\n\n  var rawEntityMap = {};\n\n  Object.keys(entityMap).forEach(function (key, index) {\n    var entity = contentState.getEntity(DraftStringKey.unstringify(key));\n    rawEntityMap[index] = {\n      type: entity.getType(),\n      mutability: entity.getMutability(),\n      data: entity.getData()\n    };\n  });\n\n  return {\n    blocks: blocks,\n    entityMap: rawEntityMap\n  };\n};\n\nvar convertFromDraftStateToRaw = function convertFromDraftStateToRaw(contentState) {\n  var rawDraftContentState = {\n    entityMap: {},\n    blocks: []\n  };\n\n  // add blocks\n  rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);\n\n  // add entities\n  rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);\n\n  return rawDraftContentState;\n};\n\nmodule.exports = convertFromDraftStateToRaw;"]},"metadata":{},"sourceType":"script"}