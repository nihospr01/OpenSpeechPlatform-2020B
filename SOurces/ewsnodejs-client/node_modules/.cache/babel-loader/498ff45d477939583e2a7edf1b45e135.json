{"ast":null,"code":"import { bisector, tickStep } from \"d3-array\";\nimport { timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond } from \"d3-time\";\nimport { timeFormat } from \"d3-time-format\";\nimport { map } from \"./array\";\nimport continuous, { copy, identity } from \"./continuous\";\nimport { initRange } from \"./init\";\nimport nice from \"./nice\";\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nexport function calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(identity, identity),\n      invert = scale.invert,\n      domain = scale.domain;\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n  var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10; // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function (i) {\n        return i[2];\n      }).right(tickIntervals, target);\n\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function (y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function (_) {\n    return arguments.length ? domain(map.call(_, number)) : domain().map(date);\n  };\n\n  scale.ticks = function (interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function (count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function (interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;\n  };\n\n  scale.copy = function () {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\nexport default function () {\n  return initRange.apply(calendar(timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-scale/src/time.js"],"names":["bisector","tickStep","timeYear","timeMonth","timeWeek","timeDay","timeHour","timeMinute","timeSecond","timeMillisecond","timeFormat","map","continuous","copy","identity","initRange","nice","durationSecond","durationMinute","durationHour","durationDay","durationWeek","durationMonth","durationYear","date","t","Date","number","calendar","year","month","week","day","hour","minute","second","millisecond","format","scale","invert","domain","formatMillisecond","formatSecond","formatMinute","formatHour","formatDay","formatWeek","formatMonth","formatYear","tickIntervals","tickFormat","tickInterval","interval","start","stop","step","target","Math","abs","i","right","length","max","every","y","_","arguments","call","ticks","d","t0","t1","r","range","reverse","count","specifier","apply"],"mappings":"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","sourcesContent":["import {bisector, tickStep} from \"d3-array\";\nimport {timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond} from \"d3-time\";\nimport {timeFormat} from \"d3-time-format\";\nimport {map} from \"./array\";\nimport continuous, {copy, identity} from \"./continuous\";\nimport {initRange} from \"./init\";\nimport nice from \"./nice\";\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nexport function calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(identity, identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map.call(_, number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\nexport default function() {\n  return initRange.apply(calendar(timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n}\n"]},"metadata":{},"sourceType":"module"}