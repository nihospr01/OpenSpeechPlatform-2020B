{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getContentStateFragment\n * @format\n * \n */\n'use strict';\n\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar removeEntitiesAtEdges = require('./removeEntitiesAtEdges');\n\nvar getContentStateFragment = function getContentStateFragment(contentState, selectionState) {\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset(); // Edge entities should be stripped to ensure that we don't preserve\n  // invalid partial entities when the fragment is reused. We do, however,\n  // preserve entities that are entirely within the selection range.\n\n  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);\n  var blockMap = contentWithoutEdgeEntities.getBlockMap();\n  var blockKeys = blockMap.keySeq();\n  var startIndex = blockKeys.indexOf(startKey);\n  var endIndex = blockKeys.indexOf(endKey) + 1;\n  return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {\n    var text = block.getText();\n    var chars = block.getCharacterList();\n\n    if (startKey === endKey) {\n      return block.merge({\n        text: text.slice(startOffset, endOffset),\n        characterList: chars.slice(startOffset, endOffset)\n      });\n    }\n\n    if (blockKey === startKey) {\n      return block.merge({\n        text: text.slice(startOffset),\n        characterList: chars.slice(startOffset)\n      });\n    }\n\n    if (blockKey === endKey) {\n      return block.merge({\n        text: text.slice(0, endOffset),\n        characterList: chars.slice(0, endOffset)\n      });\n    }\n\n    return block;\n  }));\n};\n\nmodule.exports = getContentStateFragment;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/getContentStateFragment.js"],"names":["randomizeBlockMapKeys","require","removeEntitiesAtEdges","getContentStateFragment","contentState","selectionState","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","contentWithoutEdgeEntities","blockMap","getBlockMap","blockKeys","keySeq","startIndex","indexOf","endIndex","slice","map","block","blockKey","text","getText","chars","getCharacterList","merge","characterList","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,qBAAqB,GAAGC,OAAO,CAAC,yBAAD,CAAnC;;AACA,IAAIC,qBAAqB,GAAGD,OAAO,CAAC,yBAAD,CAAnC;;AAEA,IAAIE,uBAAuB,GAAG,SAASA,uBAAT,CAAiCC,YAAjC,EAA+CC,cAA/C,EAA+D;AAC3F,MAAIC,QAAQ,GAAGD,cAAc,CAACE,WAAf,EAAf;AACA,MAAIC,WAAW,GAAGH,cAAc,CAACI,cAAf,EAAlB;AACA,MAAIC,MAAM,GAAGL,cAAc,CAACM,SAAf,EAAb;AACA,MAAIC,SAAS,GAAGP,cAAc,CAACQ,YAAf,EAAhB,CAJ2F,CAM3F;AACA;AACA;;AACA,MAAIC,0BAA0B,GAAGZ,qBAAqB,CAACE,YAAD,EAAeC,cAAf,CAAtD;AAEA,MAAIU,QAAQ,GAAGD,0BAA0B,CAACE,WAA3B,EAAf;AACA,MAAIC,SAAS,GAAGF,QAAQ,CAACG,MAAT,EAAhB;AACA,MAAIC,UAAU,GAAGF,SAAS,CAACG,OAAV,CAAkBd,QAAlB,CAAjB;AACA,MAAIe,QAAQ,GAAGJ,SAAS,CAACG,OAAV,CAAkBV,MAAlB,IAA4B,CAA3C;AAEA,SAAOV,qBAAqB,CAACe,QAAQ,CAACO,KAAT,CAAeH,UAAf,EAA2BE,QAA3B,EAAqCE,GAArC,CAAyC,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAC/F,QAAIC,IAAI,GAAGF,KAAK,CAACG,OAAN,EAAX;AACA,QAAIC,KAAK,GAAGJ,KAAK,CAACK,gBAAN,EAAZ;;AAEA,QAAIvB,QAAQ,KAAKI,MAAjB,EAAyB;AACvB,aAAOc,KAAK,CAACM,KAAN,CAAY;AACjBJ,QAAAA,IAAI,EAAEA,IAAI,CAACJ,KAAL,CAAWd,WAAX,EAAwBI,SAAxB,CADW;AAEjBmB,QAAAA,aAAa,EAAEH,KAAK,CAACN,KAAN,CAAYd,WAAZ,EAAyBI,SAAzB;AAFE,OAAZ,CAAP;AAID;;AAED,QAAIa,QAAQ,KAAKnB,QAAjB,EAA2B;AACzB,aAAOkB,KAAK,CAACM,KAAN,CAAY;AACjBJ,QAAAA,IAAI,EAAEA,IAAI,CAACJ,KAAL,CAAWd,WAAX,CADW;AAEjBuB,QAAAA,aAAa,EAAEH,KAAK,CAACN,KAAN,CAAYd,WAAZ;AAFE,OAAZ,CAAP;AAID;;AAED,QAAIiB,QAAQ,KAAKf,MAAjB,EAAyB;AACvB,aAAOc,KAAK,CAACM,KAAN,CAAY;AACjBJ,QAAAA,IAAI,EAAEA,IAAI,CAACJ,KAAL,CAAW,CAAX,EAAcV,SAAd,CADW;AAEjBmB,QAAAA,aAAa,EAAEH,KAAK,CAACN,KAAN,CAAY,CAAZ,EAAeV,SAAf;AAFE,OAAZ,CAAP;AAID;;AAED,WAAOY,KAAP;AACD,GA1B4B,CAAD,CAA5B;AA2BD,CA3CD;;AA6CAQ,MAAM,CAACC,OAAP,GAAiB9B,uBAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getContentStateFragment\n * @format\n * \n */\n\n'use strict';\n\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\nvar removeEntitiesAtEdges = require('./removeEntitiesAtEdges');\n\nvar getContentStateFragment = function getContentStateFragment(contentState, selectionState) {\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  // Edge entities should be stripped to ensure that we don't preserve\n  // invalid partial entities when the fragment is reused. We do, however,\n  // preserve entities that are entirely within the selection range.\n  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);\n\n  var blockMap = contentWithoutEdgeEntities.getBlockMap();\n  var blockKeys = blockMap.keySeq();\n  var startIndex = blockKeys.indexOf(startKey);\n  var endIndex = blockKeys.indexOf(endKey) + 1;\n\n  return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {\n    var text = block.getText();\n    var chars = block.getCharacterList();\n\n    if (startKey === endKey) {\n      return block.merge({\n        text: text.slice(startOffset, endOffset),\n        characterList: chars.slice(startOffset, endOffset)\n      });\n    }\n\n    if (blockKey === startKey) {\n      return block.merge({\n        text: text.slice(startOffset),\n        characterList: chars.slice(startOffset)\n      });\n    }\n\n    if (blockKey === endKey) {\n      return block.merge({\n        text: text.slice(0, endOffset),\n        characterList: chars.slice(0, endOffset)\n      });\n    }\n\n    return block;\n  }));\n};\n\nmodule.exports = getContentStateFragment;"]},"metadata":{},"sourceType":"script"}