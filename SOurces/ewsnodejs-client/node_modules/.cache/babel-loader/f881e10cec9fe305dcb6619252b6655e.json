{"ast":null,"code":"var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function (row, i) {\n    return f(object(row), i, columns);\n  };\n} // Compute unique columns in order of discovery.\n\n\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n  rows.forEach(function (row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\",\n      length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6) : year > 9999 ? \"+\" + pad(year, 6) : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\" : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2) + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\" : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\" : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\" : \"\");\n}\n\nexport default function (delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert,\n        columns,\n        rows = parseRows(text, function (row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [],\n        // output rows\n    N = text.length,\n        I = 0,\n        // current character index\n    n = 0,\n        // current line number\n    t,\n        // current token\n    eof = N <= 0,\n        // current token followed by EOF?\n    eol = false; // current token followed by EOL?\n    // Strip the trailing newline.\n\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL; // Unescape quotes.\n\n      var i,\n          j = I,\n          c;\n\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {\n          ;\n        }\n\n        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {\n          eol = true;\n          if (text.charCodeAt(I) === NEWLINE) ++I;\n        }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      } // Find next delimiter or newline.\n\n\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {\n          eol = true;\n          if (text.charCodeAt(I) === NEWLINE) ++I;\n        } else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      } // Return last token before EOF.\n\n\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n\n      while (t !== EOL && t !== EOF) {\n        row.push(t), t = token();\n      }\n\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function (row) {\n      return columns.map(function (column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\" : value instanceof Date ? formatDate(value) : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\" : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-dsv/src/dsv.js"],"names":["EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","pad","value","width","s","length","Array","formatYear","year","formatDate","date","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","isNaN","getUTCFullYear","getUTCMonth","getUTCDate","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","parse","text","convert","parseRows","N","I","n","t","eof","eol","token","j","c","slice","replace","preformatBody","formatValue","format","concat","formatBody","formatRows","formatRow","Date","test"],"mappings":"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","sourcesContent":["var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}\n"]},"metadata":{},"sourceType":"module"}