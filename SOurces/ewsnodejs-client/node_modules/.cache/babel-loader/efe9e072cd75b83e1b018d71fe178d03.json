{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar OrderedMap = Immutable.OrderedMap;\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {}; // we keep track of root blocks in order to update subsequent sibling links\n\n  var lastRootBlock = void 0;\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey(); // new key that we will use to build linking\n\n      var key = generateRandomKey(); // we will add it here to re-use it later\n\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/randomizeBlockMapKeys.js"],"names":["ContentBlockNode","require","Immutable","generateRandomKey","OrderedMap","randomizeContentBlockNodeKeys","blockMap","newKeysRef","lastRootBlock","withMutations","blockMapState","forEach","block","index","oldKey","getKey","nextKey","getNextSiblingKey","prevKey","getPrevSiblingKey","childrenKeys","getChildKeys","parentKey","getParentKey","key","nextBlock","get","setIn","prevBlock","parentBlock","parentChildrenList","set","indexOf","childKey","childBlock","filter","child","toArray","map","randomizeContentBlockKeys","randomizeBlockMapKeys","isTreeBasedBlockMap","first","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar OrderedMap = Immutable.OrderedMap;\n\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {};\n\n  // we keep track of root blocks in order to update subsequent sibling links\n  var lastRootBlock = void 0;\n\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey();\n\n      // new key that we will use to build linking\n      var key = generateRandomKey();\n\n      // we will add it here to re-use it later\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;"]},"metadata":{},"sourceType":"script"}