{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EditorState\n * @format\n * \n */\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar BlockTree = require('./BlockTree');\n\nvar ContentState = require('./ContentState');\n\nvar EditorBidiService = require('./EditorBidiService');\n\nvar Immutable = require('immutable');\n\nvar SelectionState = require('./SelectionState');\n\nvar OrderedSet = Immutable.OrderedSet,\n    Record = Immutable.Record,\n    Stack = Immutable.Stack;\nvar defaultRecord = {\n  allowUndo: true,\n  currentContent: null,\n  decorator: null,\n  directionMap: null,\n  forceSelection: false,\n  inCompositionMode: false,\n  inlineStyleOverride: null,\n  lastChangeType: null,\n  nativelyRenderedContent: null,\n  redoStack: Stack(),\n  selection: null,\n  treeMap: null,\n  undoStack: Stack()\n};\nvar EditorStateRecord = Record(defaultRecord);\n\nvar EditorState = function () {\n  EditorState.createEmpty = function createEmpty(decorator) {\n    return EditorState.createWithContent(ContentState.createFromText(''), decorator);\n  };\n\n  EditorState.createWithContent = function createWithContent(contentState, decorator) {\n    var firstKey = contentState.getBlockMap().first().getKey();\n    return EditorState.create({\n      currentContent: contentState,\n      undoStack: Stack(),\n      redoStack: Stack(),\n      decorator: decorator || null,\n      selection: SelectionState.createEmpty(firstKey)\n    });\n  };\n\n  EditorState.create = function create(config) {\n    var currentContent = config.currentContent,\n        decorator = config.decorator;\n\n    var recordConfig = _extends({}, config, {\n      treeMap: generateNewTreeMap(currentContent, decorator),\n      directionMap: EditorBidiService.getDirectionMap(currentContent)\n    });\n\n    return new EditorState(new EditorStateRecord(recordConfig));\n  };\n\n  EditorState.set = function set(editorState, put) {\n    var map = editorState.getImmutable().withMutations(function (state) {\n      var existingDecorator = state.get('decorator');\n      var decorator = existingDecorator;\n\n      if (put.decorator === null) {\n        decorator = null;\n      } else if (put.decorator) {\n        decorator = put.decorator;\n      }\n\n      var newContent = put.currentContent || editorState.getCurrentContent();\n\n      if (decorator !== existingDecorator) {\n        var treeMap = state.get('treeMap');\n        var newTreeMap;\n\n        if (decorator && existingDecorator) {\n          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);\n        } else {\n          newTreeMap = generateNewTreeMap(newContent, decorator);\n        }\n\n        state.merge({\n          decorator: decorator,\n          treeMap: newTreeMap,\n          nativelyRenderedContent: null\n        });\n        return;\n      }\n\n      var existingContent = editorState.getCurrentContent();\n\n      if (newContent !== existingContent) {\n        state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));\n      }\n\n      state.merge(put);\n    });\n    return new EditorState(map);\n  };\n\n  EditorState.prototype.toJS = function toJS() {\n    return this.getImmutable().toJS();\n  };\n\n  EditorState.prototype.getAllowUndo = function getAllowUndo() {\n    return this.getImmutable().get('allowUndo');\n  };\n\n  EditorState.prototype.getCurrentContent = function getCurrentContent() {\n    return this.getImmutable().get('currentContent');\n  };\n\n  EditorState.prototype.getUndoStack = function getUndoStack() {\n    return this.getImmutable().get('undoStack');\n  };\n\n  EditorState.prototype.getRedoStack = function getRedoStack() {\n    return this.getImmutable().get('redoStack');\n  };\n\n  EditorState.prototype.getSelection = function getSelection() {\n    return this.getImmutable().get('selection');\n  };\n\n  EditorState.prototype.getDecorator = function getDecorator() {\n    return this.getImmutable().get('decorator');\n  };\n\n  EditorState.prototype.isInCompositionMode = function isInCompositionMode() {\n    return this.getImmutable().get('inCompositionMode');\n  };\n\n  EditorState.prototype.mustForceSelection = function mustForceSelection() {\n    return this.getImmutable().get('forceSelection');\n  };\n\n  EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {\n    return this.getImmutable().get('nativelyRenderedContent');\n  };\n\n  EditorState.prototype.getLastChangeType = function getLastChangeType() {\n    return this.getImmutable().get('lastChangeType');\n  };\n  /**\n   * While editing, the user may apply inline style commands with a collapsed\n   * cursor, intending to type text that adopts the specified style. In this\n   * case, we track the specified style as an \"override\" that takes precedence\n   * over the inline style of the text adjacent to the cursor.\n   *\n   * If null, there is no override in place.\n   */\n\n\n  EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {\n    return this.getImmutable().get('inlineStyleOverride');\n  };\n\n  EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {\n    return EditorState.set(editorState, {\n      inlineStyleOverride: inlineStyleOverride\n    });\n  };\n  /**\n   * Get the appropriate inline style for the editor state. If an\n   * override is in place, use it. Otherwise, the current style is\n   * based on the location of the selection state.\n   */\n\n\n  EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {\n    var override = this.getInlineStyleOverride();\n\n    if (override != null) {\n      return override;\n    }\n\n    var content = this.getCurrentContent();\n    var selection = this.getSelection();\n\n    if (selection.isCollapsed()) {\n      return getInlineStyleForCollapsedSelection(content, selection);\n    }\n\n    return getInlineStyleForNonCollapsedSelection(content, selection);\n  };\n\n  EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {\n    return this.getImmutable().getIn(['treeMap', blockKey]);\n  };\n\n  EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {\n    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();\n    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);\n  };\n\n  EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {\n    var content = this.getCurrentContent();\n    var blockMap = content.getBlockMap();\n    var last = blockMap.last();\n    var end = last.getLength();\n    return this.getSelection().hasEdgeWithin(last.getKey(), end, end);\n  };\n\n  EditorState.prototype.getDirectionMap = function getDirectionMap() {\n    return this.getImmutable().get('directionMap');\n  };\n  /**\n   * Incorporate native DOM selection changes into the EditorState. This\n   * method can be used when we simply want to accept whatever the DOM\n   * has given us to represent selection, and we do not need to re-render\n   * the editor.\n   *\n   * To forcibly move the DOM selection, see `EditorState.forceSelection`.\n   */\n\n\n  EditorState.acceptSelection = function acceptSelection(editorState, selection) {\n    return updateSelection(editorState, selection, false);\n  };\n  /**\n   * At times, we need to force the DOM selection to be where we\n   * need it to be. This can occur when the anchor or focus nodes\n   * are non-text nodes, for instance. In this case, we want to trigger\n   * a re-render of the editor, which in turn forces selection into\n   * the correct place in the DOM. The `forceSelection` method\n   * accomplishes this.\n   *\n   * This method should be used in cases where you need to explicitly\n   * move the DOM selection from one place to another without a change\n   * in ContentState.\n   */\n\n\n  EditorState.forceSelection = function forceSelection(editorState, selection) {\n    if (!selection.getHasFocus()) {\n      selection = selection.set('hasFocus', true);\n    }\n\n    return updateSelection(editorState, selection, true);\n  };\n  /**\n   * Move selection to the end of the editor without forcing focus.\n   */\n\n\n  EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {\n    var content = editorState.getCurrentContent();\n    var lastBlock = content.getLastBlock();\n    var lastKey = lastBlock.getKey();\n    var length = lastBlock.getLength();\n    return EditorState.acceptSelection(editorState, new SelectionState({\n      anchorKey: lastKey,\n      anchorOffset: length,\n      focusKey: lastKey,\n      focusOffset: length,\n      isBackward: false\n    }));\n  };\n  /**\n   * Force focus to the end of the editor. This is useful in scenarios\n   * where we want to programmatically focus the input and it makes sense\n   * to allow the user to continue working seamlessly.\n   */\n\n\n  EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {\n    var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);\n    return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());\n  };\n  /**\n   * Push the current ContentState onto the undo stack if it should be\n   * considered a boundary state, and set the provided ContentState as the\n   * new current content.\n   */\n\n\n  EditorState.push = function push(editorState, contentState, changeType) {\n    if (editorState.getCurrentContent() === contentState) {\n      return editorState;\n    }\n\n    var forceSelection = changeType !== 'insert-characters';\n    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());\n\n    if (!editorState.getAllowUndo()) {\n      return EditorState.set(editorState, {\n        currentContent: contentState,\n        directionMap: directionMap,\n        lastChangeType: changeType,\n        selection: contentState.getSelectionAfter(),\n        forceSelection: forceSelection,\n        inlineStyleOverride: null\n      });\n    }\n\n    var selection = editorState.getSelection();\n    var currentContent = editorState.getCurrentContent();\n    var undoStack = editorState.getUndoStack();\n    var newContent = contentState;\n\n    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {\n      undoStack = undoStack.push(currentContent);\n      newContent = newContent.set('selectionBefore', selection);\n    } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {\n      // Preserve the previous selection.\n      newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());\n    }\n\n    var inlineStyleOverride = editorState.getInlineStyleOverride(); // Don't discard inline style overrides for the following change types:\n\n    var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];\n\n    if (overrideChangeTypes.indexOf(changeType) === -1) {\n      inlineStyleOverride = null;\n    }\n\n    var editorStateChanges = {\n      currentContent: newContent,\n      directionMap: directionMap,\n      undoStack: undoStack,\n      redoStack: Stack(),\n      lastChangeType: changeType,\n      selection: contentState.getSelectionAfter(),\n      forceSelection: forceSelection,\n      inlineStyleOverride: inlineStyleOverride\n    };\n    return EditorState.set(editorState, editorStateChanges);\n  };\n  /**\n   * Make the top ContentState in the undo stack the new current content and\n   * push the current content onto the redo stack.\n   */\n\n\n  EditorState.undo = function undo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var undoStack = editorState.getUndoStack();\n    var newCurrentContent = undoStack.peek();\n\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: undoStack.shift(),\n      redoStack: editorState.getRedoStack().push(currentContent),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'undo',\n      nativelyRenderedContent: null,\n      selection: currentContent.getSelectionBefore()\n    });\n  };\n  /**\n   * Make the top ContentState in the redo stack the new current content and\n   * push the current content onto the undo stack.\n   */\n\n\n  EditorState.redo = function redo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var redoStack = editorState.getRedoStack();\n    var newCurrentContent = redoStack.peek();\n\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: editorState.getUndoStack().push(currentContent),\n      redoStack: redoStack.shift(),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'redo',\n      nativelyRenderedContent: null,\n      selection: newCurrentContent.getSelectionAfter()\n    });\n  };\n  /**\n   * Not for public consumption.\n   */\n\n\n  function EditorState(immutable) {\n    _classCallCheck(this, EditorState);\n\n    this._immutable = immutable;\n  }\n  /**\n   * Not for public consumption.\n   */\n\n\n  EditorState.prototype.getImmutable = function getImmutable() {\n    return this._immutable;\n  };\n\n  return EditorState;\n}();\n/**\n * Set the supplied SelectionState as the new current selection, and set\n * the `force` flag to trigger manual selection placement by the view.\n */\n\n\nfunction updateSelection(editorState, selection, forceSelection) {\n  return EditorState.set(editorState, {\n    selection: selection,\n    forceSelection: forceSelection,\n    nativelyRenderedContent: null,\n    inlineStyleOverride: null\n  });\n}\n/**\n * Regenerate the entire tree map for a given ContentState and decorator.\n * Returns an OrderedMap that maps all available ContentBlock objects.\n */\n\n\nfunction generateNewTreeMap(contentState, decorator) {\n  return contentState.getBlockMap().map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }).toOrderedMap();\n}\n/**\n * Regenerate tree map objects for all ContentBlocks that have changed\n * between the current editorState and newContent. Returns an OrderedMap\n * with only changed regenerated tree map objects.\n */\n\n\nfunction regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {\n  var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);\n  var prevBlockMap = contentState.getBlockMap();\n  var prevTreeMap = editorState.getImmutable().get('treeMap');\n  return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {\n    return block !== prevBlockMap.get(key);\n  }).map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }));\n}\n/**\n * Generate tree map objects for a new decorator object, preserving any\n * decorations that are unchanged from the previous decorator.\n *\n * Note that in order for this to perform optimally, decoration Lists for\n * decorators should be preserved when possible to allow for direct immutable\n * List comparison.\n */\n\n\nfunction regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {\n  return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {\n    return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);\n  }).map(function (block) {\n    return BlockTree.generate(content, block, decorator);\n  }));\n}\n/**\n * Return whether a change should be considered a boundary state, given\n * the previous change type. Allows us to discard potential boundary states\n * during standard typing or deletion behavior.\n */\n\n\nfunction mustBecomeBoundary(editorState, changeType) {\n  var lastChangeType = editorState.getLastChangeType();\n  return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';\n}\n\nfunction getInlineStyleForCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey); // If the cursor is not at the start of the block, look backward to\n  // preserve the style of the preceding character.\n\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  } // The caret is at position zero in this block. If the block has any\n  // text at all, use the style of the first character.\n\n\n  if (startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(0);\n  } // Otherwise, look upward in the document to find the closest character.\n\n\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction getInlineStyleForNonCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey); // If there is a character just inside the selection, use its style.\n\n  if (startOffset < startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(startOffset);\n  } // Check if the selection at the end of a non-empty block. Use the last\n  // style in the block.\n\n\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  } // Otherwise, look upward in the document to find the closest character.\n\n\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction lookUpwardForInlineStyle(content, fromKey) {\n  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {\n    return k === fromKey;\n  }).skip(1).skipUntil(function (block, _) {\n    return block.getLength();\n  }).first();\n  if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);\n  return OrderedSet();\n}\n\nmodule.exports = EditorState;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/EditorState.js"],"names":["_assign","require","_extends","target","i","arguments","length","source","key","Object","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","BlockTree","ContentState","EditorBidiService","Immutable","SelectionState","OrderedSet","Record","Stack","defaultRecord","allowUndo","currentContent","decorator","directionMap","forceSelection","inCompositionMode","inlineStyleOverride","lastChangeType","nativelyRenderedContent","redoStack","selection","treeMap","undoStack","EditorStateRecord","EditorState","createEmpty","createWithContent","createFromText","contentState","firstKey","getBlockMap","first","getKey","create","config","recordConfig","generateNewTreeMap","getDirectionMap","set","editorState","put","map","getImmutable","withMutations","state","existingDecorator","get","newContent","getCurrentContent","newTreeMap","regenerateTreeForNewDecorator","merge","existingContent","regenerateTreeForNewBlocks","getEntityMap","toJS","getAllowUndo","getUndoStack","getRedoStack","getSelection","getDecorator","isInCompositionMode","mustForceSelection","getNativelyRenderedContent","getLastChangeType","getInlineStyleOverride","setInlineStyleOverride","getCurrentInlineStyle","override","content","isCollapsed","getInlineStyleForCollapsedSelection","getInlineStyleForNonCollapsedSelection","getBlockTree","blockKey","getIn","isSelectionAtStartOfContent","hasEdgeWithin","isSelectionAtEndOfContent","blockMap","last","end","getLength","acceptSelection","updateSelection","getHasFocus","moveSelectionToEnd","lastBlock","getLastBlock","lastKey","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","moveFocusToEnd","afterSelectionMove","push","changeType","getSelectionAfter","mustBecomeBoundary","getSelectionBefore","overrideChangeTypes","indexOf","editorStateChanges","undo","newCurrentContent","peek","shift","redo","immutable","_immutable","block","generate","toOrderedMap","newBlockMap","newEntityMap","prevBlockMap","prevTreeMap","toSeq","filter","previousTreeMap","getDecorations","startKey","getStartKey","startOffset","getStartOffset","startBlock","getBlockForKey","getInlineStyleAt","lookUpwardForInlineStyle","fromKey","lastNonEmpty","reverse","skipUntil","_","k","skip","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EditorState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BlockTree = require('./BlockTree');\nvar ContentState = require('./ContentState');\nvar EditorBidiService = require('./EditorBidiService');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar OrderedSet = Immutable.OrderedSet,\n    Record = Immutable.Record,\n    Stack = Immutable.Stack;\n\n\nvar defaultRecord = {\n  allowUndo: true,\n  currentContent: null,\n  decorator: null,\n  directionMap: null,\n  forceSelection: false,\n  inCompositionMode: false,\n  inlineStyleOverride: null,\n  lastChangeType: null,\n  nativelyRenderedContent: null,\n  redoStack: Stack(),\n  selection: null,\n  treeMap: null,\n  undoStack: Stack()\n};\n\nvar EditorStateRecord = Record(defaultRecord);\n\nvar EditorState = function () {\n  EditorState.createEmpty = function createEmpty(decorator) {\n    return EditorState.createWithContent(ContentState.createFromText(''), decorator);\n  };\n\n  EditorState.createWithContent = function createWithContent(contentState, decorator) {\n    var firstKey = contentState.getBlockMap().first().getKey();\n    return EditorState.create({\n      currentContent: contentState,\n      undoStack: Stack(),\n      redoStack: Stack(),\n      decorator: decorator || null,\n      selection: SelectionState.createEmpty(firstKey)\n    });\n  };\n\n  EditorState.create = function create(config) {\n    var currentContent = config.currentContent,\n        decorator = config.decorator;\n\n    var recordConfig = _extends({}, config, {\n      treeMap: generateNewTreeMap(currentContent, decorator),\n      directionMap: EditorBidiService.getDirectionMap(currentContent)\n    });\n    return new EditorState(new EditorStateRecord(recordConfig));\n  };\n\n  EditorState.set = function set(editorState, put) {\n    var map = editorState.getImmutable().withMutations(function (state) {\n      var existingDecorator = state.get('decorator');\n      var decorator = existingDecorator;\n      if (put.decorator === null) {\n        decorator = null;\n      } else if (put.decorator) {\n        decorator = put.decorator;\n      }\n\n      var newContent = put.currentContent || editorState.getCurrentContent();\n\n      if (decorator !== existingDecorator) {\n        var treeMap = state.get('treeMap');\n        var newTreeMap;\n        if (decorator && existingDecorator) {\n          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);\n        } else {\n          newTreeMap = generateNewTreeMap(newContent, decorator);\n        }\n\n        state.merge({\n          decorator: decorator,\n          treeMap: newTreeMap,\n          nativelyRenderedContent: null\n        });\n        return;\n      }\n\n      var existingContent = editorState.getCurrentContent();\n      if (newContent !== existingContent) {\n        state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));\n      }\n\n      state.merge(put);\n    });\n\n    return new EditorState(map);\n  };\n\n  EditorState.prototype.toJS = function toJS() {\n    return this.getImmutable().toJS();\n  };\n\n  EditorState.prototype.getAllowUndo = function getAllowUndo() {\n    return this.getImmutable().get('allowUndo');\n  };\n\n  EditorState.prototype.getCurrentContent = function getCurrentContent() {\n    return this.getImmutable().get('currentContent');\n  };\n\n  EditorState.prototype.getUndoStack = function getUndoStack() {\n    return this.getImmutable().get('undoStack');\n  };\n\n  EditorState.prototype.getRedoStack = function getRedoStack() {\n    return this.getImmutable().get('redoStack');\n  };\n\n  EditorState.prototype.getSelection = function getSelection() {\n    return this.getImmutable().get('selection');\n  };\n\n  EditorState.prototype.getDecorator = function getDecorator() {\n    return this.getImmutable().get('decorator');\n  };\n\n  EditorState.prototype.isInCompositionMode = function isInCompositionMode() {\n    return this.getImmutable().get('inCompositionMode');\n  };\n\n  EditorState.prototype.mustForceSelection = function mustForceSelection() {\n    return this.getImmutable().get('forceSelection');\n  };\n\n  EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {\n    return this.getImmutable().get('nativelyRenderedContent');\n  };\n\n  EditorState.prototype.getLastChangeType = function getLastChangeType() {\n    return this.getImmutable().get('lastChangeType');\n  };\n\n  /**\n   * While editing, the user may apply inline style commands with a collapsed\n   * cursor, intending to type text that adopts the specified style. In this\n   * case, we track the specified style as an \"override\" that takes precedence\n   * over the inline style of the text adjacent to the cursor.\n   *\n   * If null, there is no override in place.\n   */\n\n\n  EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {\n    return this.getImmutable().get('inlineStyleOverride');\n  };\n\n  EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {\n    return EditorState.set(editorState, { inlineStyleOverride: inlineStyleOverride });\n  };\n\n  /**\n   * Get the appropriate inline style for the editor state. If an\n   * override is in place, use it. Otherwise, the current style is\n   * based on the location of the selection state.\n   */\n\n\n  EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {\n    var override = this.getInlineStyleOverride();\n    if (override != null) {\n      return override;\n    }\n\n    var content = this.getCurrentContent();\n    var selection = this.getSelection();\n\n    if (selection.isCollapsed()) {\n      return getInlineStyleForCollapsedSelection(content, selection);\n    }\n\n    return getInlineStyleForNonCollapsedSelection(content, selection);\n  };\n\n  EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {\n    return this.getImmutable().getIn(['treeMap', blockKey]);\n  };\n\n  EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {\n    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();\n    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);\n  };\n\n  EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {\n    var content = this.getCurrentContent();\n    var blockMap = content.getBlockMap();\n    var last = blockMap.last();\n    var end = last.getLength();\n    return this.getSelection().hasEdgeWithin(last.getKey(), end, end);\n  };\n\n  EditorState.prototype.getDirectionMap = function getDirectionMap() {\n    return this.getImmutable().get('directionMap');\n  };\n\n  /**\n   * Incorporate native DOM selection changes into the EditorState. This\n   * method can be used when we simply want to accept whatever the DOM\n   * has given us to represent selection, and we do not need to re-render\n   * the editor.\n   *\n   * To forcibly move the DOM selection, see `EditorState.forceSelection`.\n   */\n\n\n  EditorState.acceptSelection = function acceptSelection(editorState, selection) {\n    return updateSelection(editorState, selection, false);\n  };\n\n  /**\n   * At times, we need to force the DOM selection to be where we\n   * need it to be. This can occur when the anchor or focus nodes\n   * are non-text nodes, for instance. In this case, we want to trigger\n   * a re-render of the editor, which in turn forces selection into\n   * the correct place in the DOM. The `forceSelection` method\n   * accomplishes this.\n   *\n   * This method should be used in cases where you need to explicitly\n   * move the DOM selection from one place to another without a change\n   * in ContentState.\n   */\n\n\n  EditorState.forceSelection = function forceSelection(editorState, selection) {\n    if (!selection.getHasFocus()) {\n      selection = selection.set('hasFocus', true);\n    }\n    return updateSelection(editorState, selection, true);\n  };\n\n  /**\n   * Move selection to the end of the editor without forcing focus.\n   */\n\n\n  EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {\n    var content = editorState.getCurrentContent();\n    var lastBlock = content.getLastBlock();\n    var lastKey = lastBlock.getKey();\n    var length = lastBlock.getLength();\n\n    return EditorState.acceptSelection(editorState, new SelectionState({\n      anchorKey: lastKey,\n      anchorOffset: length,\n      focusKey: lastKey,\n      focusOffset: length,\n      isBackward: false\n    }));\n  };\n\n  /**\n   * Force focus to the end of the editor. This is useful in scenarios\n   * where we want to programmatically focus the input and it makes sense\n   * to allow the user to continue working seamlessly.\n   */\n\n\n  EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {\n    var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);\n    return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());\n  };\n\n  /**\n   * Push the current ContentState onto the undo stack if it should be\n   * considered a boundary state, and set the provided ContentState as the\n   * new current content.\n   */\n\n\n  EditorState.push = function push(editorState, contentState, changeType) {\n    if (editorState.getCurrentContent() === contentState) {\n      return editorState;\n    }\n\n    var forceSelection = changeType !== 'insert-characters';\n    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());\n\n    if (!editorState.getAllowUndo()) {\n      return EditorState.set(editorState, {\n        currentContent: contentState,\n        directionMap: directionMap,\n        lastChangeType: changeType,\n        selection: contentState.getSelectionAfter(),\n        forceSelection: forceSelection,\n        inlineStyleOverride: null\n      });\n    }\n\n    var selection = editorState.getSelection();\n    var currentContent = editorState.getCurrentContent();\n    var undoStack = editorState.getUndoStack();\n    var newContent = contentState;\n\n    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {\n      undoStack = undoStack.push(currentContent);\n      newContent = newContent.set('selectionBefore', selection);\n    } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {\n      // Preserve the previous selection.\n      newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());\n    }\n\n    var inlineStyleOverride = editorState.getInlineStyleOverride();\n\n    // Don't discard inline style overrides for the following change types:\n    var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];\n\n    if (overrideChangeTypes.indexOf(changeType) === -1) {\n      inlineStyleOverride = null;\n    }\n\n    var editorStateChanges = {\n      currentContent: newContent,\n      directionMap: directionMap,\n      undoStack: undoStack,\n      redoStack: Stack(),\n      lastChangeType: changeType,\n      selection: contentState.getSelectionAfter(),\n      forceSelection: forceSelection,\n      inlineStyleOverride: inlineStyleOverride\n    };\n\n    return EditorState.set(editorState, editorStateChanges);\n  };\n\n  /**\n   * Make the top ContentState in the undo stack the new current content and\n   * push the current content onto the redo stack.\n   */\n\n\n  EditorState.undo = function undo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var undoStack = editorState.getUndoStack();\n    var newCurrentContent = undoStack.peek();\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: undoStack.shift(),\n      redoStack: editorState.getRedoStack().push(currentContent),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'undo',\n      nativelyRenderedContent: null,\n      selection: currentContent.getSelectionBefore()\n    });\n  };\n\n  /**\n   * Make the top ContentState in the redo stack the new current content and\n   * push the current content onto the undo stack.\n   */\n\n\n  EditorState.redo = function redo(editorState) {\n    if (!editorState.getAllowUndo()) {\n      return editorState;\n    }\n\n    var redoStack = editorState.getRedoStack();\n    var newCurrentContent = redoStack.peek();\n    if (!newCurrentContent) {\n      return editorState;\n    }\n\n    var currentContent = editorState.getCurrentContent();\n    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());\n\n    return EditorState.set(editorState, {\n      currentContent: newCurrentContent,\n      directionMap: directionMap,\n      undoStack: editorState.getUndoStack().push(currentContent),\n      redoStack: redoStack.shift(),\n      forceSelection: true,\n      inlineStyleOverride: null,\n      lastChangeType: 'redo',\n      nativelyRenderedContent: null,\n      selection: newCurrentContent.getSelectionAfter()\n    });\n  };\n\n  /**\n   * Not for public consumption.\n   */\n\n\n  function EditorState(immutable) {\n    _classCallCheck(this, EditorState);\n\n    this._immutable = immutable;\n  }\n\n  /**\n   * Not for public consumption.\n   */\n\n\n  EditorState.prototype.getImmutable = function getImmutable() {\n    return this._immutable;\n  };\n\n  return EditorState;\n}();\n\n/**\n * Set the supplied SelectionState as the new current selection, and set\n * the `force` flag to trigger manual selection placement by the view.\n */\n\n\nfunction updateSelection(editorState, selection, forceSelection) {\n  return EditorState.set(editorState, {\n    selection: selection,\n    forceSelection: forceSelection,\n    nativelyRenderedContent: null,\n    inlineStyleOverride: null\n  });\n}\n\n/**\n * Regenerate the entire tree map for a given ContentState and decorator.\n * Returns an OrderedMap that maps all available ContentBlock objects.\n */\nfunction generateNewTreeMap(contentState, decorator) {\n  return contentState.getBlockMap().map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }).toOrderedMap();\n}\n\n/**\n * Regenerate tree map objects for all ContentBlocks that have changed\n * between the current editorState and newContent. Returns an OrderedMap\n * with only changed regenerated tree map objects.\n */\nfunction regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {\n  var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);\n  var prevBlockMap = contentState.getBlockMap();\n  var prevTreeMap = editorState.getImmutable().get('treeMap');\n  return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {\n    return block !== prevBlockMap.get(key);\n  }).map(function (block) {\n    return BlockTree.generate(contentState, block, decorator);\n  }));\n}\n\n/**\n * Generate tree map objects for a new decorator object, preserving any\n * decorations that are unchanged from the previous decorator.\n *\n * Note that in order for this to perform optimally, decoration Lists for\n * decorators should be preserved when possible to allow for direct immutable\n * List comparison.\n */\nfunction regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {\n  return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {\n    return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);\n  }).map(function (block) {\n    return BlockTree.generate(content, block, decorator);\n  }));\n}\n\n/**\n * Return whether a change should be considered a boundary state, given\n * the previous change type. Allows us to discard potential boundary states\n * during standard typing or deletion behavior.\n */\nfunction mustBecomeBoundary(editorState, changeType) {\n  var lastChangeType = editorState.getLastChangeType();\n  return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';\n}\n\nfunction getInlineStyleForCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey);\n\n  // If the cursor is not at the start of the block, look backward to\n  // preserve the style of the preceding character.\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  }\n\n  // The caret is at position zero in this block. If the block has any\n  // text at all, use the style of the first character.\n  if (startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(0);\n  }\n\n  // Otherwise, look upward in the document to find the closest character.\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction getInlineStyleForNonCollapsedSelection(content, selection) {\n  var startKey = selection.getStartKey();\n  var startOffset = selection.getStartOffset();\n  var startBlock = content.getBlockForKey(startKey);\n\n  // If there is a character just inside the selection, use its style.\n  if (startOffset < startBlock.getLength()) {\n    return startBlock.getInlineStyleAt(startOffset);\n  }\n\n  // Check if the selection at the end of a non-empty block. Use the last\n  // style in the block.\n  if (startOffset > 0) {\n    return startBlock.getInlineStyleAt(startOffset - 1);\n  }\n\n  // Otherwise, look upward in the document to find the closest character.\n  return lookUpwardForInlineStyle(content, startKey);\n}\n\nfunction lookUpwardForInlineStyle(content, fromKey) {\n  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {\n    return k === fromKey;\n  }).skip(1).skipUntil(function (block, _) {\n    return block.getLength();\n  }).first();\n\n  if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);\n  return OrderedSet();\n}\n\nmodule.exports = EditorState;"]},"metadata":{},"sourceType":"script"}