{"ast":null,"code":"import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function _trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      if (!('value' in this.props || 'min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (this.props.min === prevProps.min && this.props.max === prevProps.max && shallowEqual(this.props.value, prevProps.value)) {\n        return;\n      }\n\n      var _props = this.props,\n          onChange = _props.onChange,\n          value = _props.value;\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends({}, this.state, state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var _props2 = this.props,\n          reverse = _props2.reverse,\n          vertical = _props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n          bounds = _state.bounds,\n          recent = _state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props3 = this.props,\n          marks = _props3.marks,\n          step = _props3.step,\n          min = _props3.min,\n          max = _props3.max;\n      var cache = this._getPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(value) {\n      var _state2 = this.state,\n          handle = _state2.handle,\n          bounds = _state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var _state3 = this.state,\n          handle = _state3.handle,\n          bounds = _state3.bounds;\n      var _props4 = this.props,\n          prefixCls = _props4.prefixCls,\n          vertical = _props4.vertical,\n          included = _props4.included,\n          disabled = _props4.disabled,\n          min = _props4.min,\n          max = _props4.max,\n          reverse = _props4.reverse,\n          handleGenerator = _props4.handle,\n          trackStyle = _props4.trackStyle,\n          handleStyle = _props4.handleStyle,\n          tabIndex = _props4.tabIndex;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var _tabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          _tabIndex = null;\n        }\n\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: _tabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(props, state) {\n      if ('value' in props || 'min' in props || 'max' in props) {\n        var value = props.value || state.bounds;\n        var nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            bounds: state.bounds,\n            props: props\n          });\n        });\n\n        if (nextBounds.length === state.bounds.length && nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n\n        return _extends({}, state, {\n          bounds: nextBounds\n        });\n      }\n\n      return null;\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.propTypes = {\n  autoFocus: PropTypes.bool,\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  reverse: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\n  min: PropTypes.number,\n  max: PropTypes.number\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\npolyfill(Range);\nexport default createSlider(Range);","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/rc-slider/es/Range.js"],"names":["_defineProperty","_extends","_toConsumableArray","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","React","PropTypes","classNames","polyfill","shallowEqual","Track","createSlider","utils","_trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","Range","_React$Component","_this","__proto__","Object","getPrototypeOf","call","onEnd","force","state","removeDocumentEvents","onAfterChange","getValue","setState","count","min","max","initialValue","Array","apply","map","defaultValue","v","i","recent","key","componentDidUpdate","prevProps","prevState","_this2","_props","onChange","currentValue","some","isValueOutOfRange","newValues","isNotControlled","controlledState","forEach","item","keys","data","changedValue","onStart","position","onBeforeChange","calcValueByPos","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","nextBounds","concat","onMove","e","pauseEvent","oldValue","moveTo","onKeyboard","_props2","reverse","vertical","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","_state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_props3","marks","step","cache","_getPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","trimAlignValue","_state2","render","_this4","_state3","_props4","prefixCls","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","offsets","calcOffset","handleClassName","handles","_classNames","_tabIndex","className","offset","dragging","index","style","ref","h","saveHandle","tracks","slice","_","_classNames2","trackClassName","createElement","getDerivedStateFromProps","every","Component","displayName","propTypes","autoFocus","bool","arrayOf","number","oneOfType","defaultProps"],"mappings":"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","sourcesContent":["import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function _trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      if (!('value' in this.props || 'min' in this.props || 'max' in this.props)) {\n        return;\n      }\n      if (this.props.min === prevProps.min && this.props.max === prevProps.max && shallowEqual(this.props.value, prevProps.value)) {\n        return;\n      }\n      var _props = this.props,\n          onChange = _props.onChange,\n          value = _props.value;\n\n      var currentValue = value || prevState.bounds;\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends({}, this.state, state);\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({ bounds: nextBounds });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var _props2 = this.props,\n          reverse = _props2.reverse,\n          vertical = _props2.vertical;\n\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n          bounds = _state.bounds,\n          recent = _state.recent;\n\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n\n      return bounds[bounds.length - 1];\n    }\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props3 = this.props,\n          marks = _props3.marks,\n          step = _props3.step,\n          min = _props3.min,\n          max = _props3.max;\n\n      var cache = this._getPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = { marks: marks, step: step, points: points };\n      }\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n\n      threshold = Number(threshold);\n\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(value) {\n      var _state2 = this.state,\n          handle = _state2.handle,\n          bounds = _state2.bounds;\n\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var _state3 = this.state,\n          handle = _state3.handle,\n          bounds = _state3.bounds;\n      var _props4 = this.props,\n          prefixCls = _props4.prefixCls,\n          vertical = _props4.vertical,\n          included = _props4.included,\n          disabled = _props4.disabled,\n          min = _props4.min,\n          max = _props4.max,\n          reverse = _props4.reverse,\n          handleGenerator = _props4.handle,\n          trackStyle = _props4.trackStyle,\n          handleStyle = _props4.handleStyle,\n          tabIndex = _props4.tabIndex;\n\n\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var _tabIndex = tabIndex[i] || 0;\n        if (disabled || tabIndex[i] === null) {\n          _tabIndex = null;\n        }\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: _tabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n\n      return { tracks: tracks, handles: handles };\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(props, state) {\n      if ('value' in props || 'min' in props || 'max' in props) {\n        var value = props.value || state.bounds;\n        var nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            bounds: state.bounds,\n            props: props\n          });\n        });\n        if (nextBounds.length === state.bounds.length && nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n        return _extends({}, state, {\n          bounds: nextBounds\n        });\n      }\n      return null;\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.propTypes = {\n  autoFocus: PropTypes.bool,\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  reverse: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\n  min: PropTypes.number,\n  max: PropTypes.number\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\n\n\npolyfill(Range);\n\nexport default createSlider(Range);"]},"metadata":{},"sourceType":"module"}