{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @format\n * \n */\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\n\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\n\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar nullthrows = require('fbjs/lib/nullthrows');\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\n\n\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE; // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true; // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset); // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n/**\n * Identify the first leaf descendant for the given node.\n */\n\n\nfunction getFirstLeaf(node) {\n  while (node.firstChild && ( // data-blocks has no offset\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n\n  return node;\n}\n/**\n * Identify the last leaf descendant for the given node.\n */\n\n\nfunction getLastLeaf(node) {\n  while (node.lastChild && ( // data-blocks has no offset\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0; // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  } // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n\n\n  if (childOffset === 0) {\n    var key = null;\n\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\n\n\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js"],"names":["findAncestorOffsetKey","require","getSelectionOffsetKeyForNode","getUpdatedSelectionState","invariant","nullthrows","getDraftEditorSelectionWithNodes","editorState","root","anchorNode","anchorOffset","focusNode","focusOffset","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","selectionState","needsRecovery","anchorPoint","focusPoint","key","offset","getPointForNonTextNode","firstChild","nodeName","getFirstLeaf","node","Element","getAttribute","getLastLeaf","lastChild","editorRoot","startNode","childOffset","offsetKey","process","env","NODE_ENV","childNodes","length","firstLeaf","nodeBeforeCursor","leafKey","textLength","getTextContentLength","lastLeaf","textContent","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @format\n * \n */\n\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\n\n  // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true;\n\n  // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n\n    // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n\n/**\n * Identify the first leaf descendant for the given node.\n */\nfunction getFirstLeaf(node) {\n  while (node.firstChild && (\n  // data-blocks has no offset\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Identify the last leaf descendant for the given node.\n */\nfunction getLastLeaf(node) {\n  while (node.lastChild && (\n  // data-blocks has no offset\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;\n\n  // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  }\n\n  // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return { key: key, offset: 0 };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;"]},"metadata":{},"sourceType":"script"}