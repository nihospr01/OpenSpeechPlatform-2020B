{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/draft-js/lib/moveBlockInContentState.js"],"names":["ContentBlockNode","require","Immutable","getNextDelimiterBlockKey","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","process","env","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  }\n  // possible values of 'insertionMode' are: 'after', 'before'\n  var isInsertedAfterTarget = insertionMode === 'after';\n\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    });\n\n    // update old prev\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    });\n\n    // update old next\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    });\n\n    // update new next\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n\n    // update new prev\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    });\n\n    // update new parent\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;"]},"metadata":{},"sourceType":"script"}