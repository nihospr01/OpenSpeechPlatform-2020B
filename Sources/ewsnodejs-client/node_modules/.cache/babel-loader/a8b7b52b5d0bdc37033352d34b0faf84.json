{"ast":null,"code":"import { RedBlackNode } from \"./RedBlackTree\";\nimport { createCell } from \"./Cell\";\nimport { attachCircle, detachCircle } from \"./Circle\";\nimport { createEdge, setEdgeEnd } from \"./Edge\";\nimport { beaches, epsilon } from \"./Diagram\";\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge = this.site = this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach();\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nexport function removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n  detachBeach(beach);\n  var lArc = previous;\n\n  while (lArc.circle && Math.abs(x - lArc.circle.x) < epsilon && Math.abs(y - lArc.circle.cy) < epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n  var rArc = next;\n\n  while (rArc.circle && Math.abs(x - rArc.circle.x) < epsilon && Math.abs(y - rArc.circle.cy) < epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n  var nArcs = disappearing.length,\n      iArc;\n\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\nexport function addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon) node = node.L;else {\n      dxr = x - rightBreakPoint(node, directrix);\n\n      if (dxr > epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n\n        node = node.R;\n      } else {\n        if (dxl > -epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) {\n    // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  } // else lArc !== rArc\n\n\n  detachCircle(lArc);\n  detachCircle(rArc);\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n  if (!pby2) return rfocx;\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n  if (!plby2) return lfocx;\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-voronoi/src/Beach.js"],"names":["RedBlackNode","createCell","attachCircle","detachCircle","createEdge","setEdgeEnd","beaches","epsilon","beachPool","Beach","edge","site","circle","createBeach","beach","pop","detachBeach","remove","push","removeBeach","x","y","cy","vertex","previous","P","next","N","disappearing","lArc","Math","abs","unshift","rArc","nArcs","length","iArc","addBeach","directrix","dxl","dxr","node","_","leftBreakPoint","L","rightBreakPoint","R","newArc","insert","lSite","ax","ay","bx","by","rSite","cx","d","hb","hc","arc","rfocx","rfocy","pby2","Infinity","lfocx","lfocy","plby2","hl","aby2","b","sqrt"],"mappings":"AAAA,SAAQA,YAAR,QAA2B,gBAA3B;AACA,SAAQC,UAAR,QAAyB,QAAzB;AACA,SAAQC,YAAR,EAAsBC,YAAtB,QAAyC,UAAzC;AACA,SAAQC,UAAR,EAAoBC,UAApB,QAAqC,QAArC;AACA,SAAQC,OAAR,EAAiBC,OAAjB,QAA+B,WAA/B;AAEA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,SAASC,KAAT,GAAiB;AACfT,EAAAA,YAAY,CAAC,IAAD,CAAZ;AACA,OAAKU,IAAL,GACA,KAAKC,IAAL,GACA,KAAKC,MAAL,GAAc,IAFd;AAGD;;AAED,SAASC,WAAT,CAAqBF,IAArB,EAA2B;AACzB,MAAIG,KAAK,GAAGN,SAAS,CAACO,GAAV,MAAmB,IAAIN,KAAJ,EAA/B;AACAK,EAAAA,KAAK,CAACH,IAAN,GAAaA,IAAb;AACA,SAAOG,KAAP;AACD;;AAED,SAASE,WAAT,CAAqBF,KAArB,EAA4B;AAC1BX,EAAAA,YAAY,CAACW,KAAD,CAAZ;AACAR,EAAAA,OAAO,CAACW,MAAR,CAAeH,KAAf;AACAN,EAAAA,SAAS,CAACU,IAAV,CAAeJ,KAAf;AACAd,EAAAA,YAAY,CAACc,KAAD,CAAZ;AACD;;AAED,OAAO,SAASK,WAAT,CAAqBL,KAArB,EAA4B;AACjC,MAAIF,MAAM,GAAGE,KAAK,CAACF,MAAnB;AAAA,MACIQ,CAAC,GAAGR,MAAM,CAACQ,CADf;AAAA,MAEIC,CAAC,GAAGT,MAAM,CAACU,EAFf;AAAA,MAGIC,MAAM,GAAG,CAACH,CAAD,EAAIC,CAAJ,CAHb;AAAA,MAIIG,QAAQ,GAAGV,KAAK,CAACW,CAJrB;AAAA,MAKIC,IAAI,GAAGZ,KAAK,CAACa,CALjB;AAAA,MAMIC,YAAY,GAAG,CAACd,KAAD,CANnB;AAQAE,EAAAA,WAAW,CAACF,KAAD,CAAX;AAEA,MAAIe,IAAI,GAAGL,QAAX;;AACA,SAAOK,IAAI,CAACjB,MAAL,IACAkB,IAAI,CAACC,GAAL,CAASX,CAAC,GAAGS,IAAI,CAACjB,MAAL,CAAYQ,CAAzB,IAA8Bb,OAD9B,IAEAuB,IAAI,CAACC,GAAL,CAASV,CAAC,GAAGQ,IAAI,CAACjB,MAAL,CAAYU,EAAzB,IAA+Bf,OAFtC,EAE+C;AAC7CiB,IAAAA,QAAQ,GAAGK,IAAI,CAACJ,CAAhB;AACAG,IAAAA,YAAY,CAACI,OAAb,CAAqBH,IAArB;AACAb,IAAAA,WAAW,CAACa,IAAD,CAAX;AACAA,IAAAA,IAAI,GAAGL,QAAP;AACD;;AAEDI,EAAAA,YAAY,CAACI,OAAb,CAAqBH,IAArB;AACA1B,EAAAA,YAAY,CAAC0B,IAAD,CAAZ;AAEA,MAAII,IAAI,GAAGP,IAAX;;AACA,SAAOO,IAAI,CAACrB,MAAL,IACAkB,IAAI,CAACC,GAAL,CAASX,CAAC,GAAGa,IAAI,CAACrB,MAAL,CAAYQ,CAAzB,IAA8Bb,OAD9B,IAEAuB,IAAI,CAACC,GAAL,CAASV,CAAC,GAAGY,IAAI,CAACrB,MAAL,CAAYU,EAAzB,IAA+Bf,OAFtC,EAE+C;AAC7CmB,IAAAA,IAAI,GAAGO,IAAI,CAACN,CAAZ;AACAC,IAAAA,YAAY,CAACV,IAAb,CAAkBe,IAAlB;AACAjB,IAAAA,WAAW,CAACiB,IAAD,CAAX;AACAA,IAAAA,IAAI,GAAGP,IAAP;AACD;;AAEDE,EAAAA,YAAY,CAACV,IAAb,CAAkBe,IAAlB;AACA9B,EAAAA,YAAY,CAAC8B,IAAD,CAAZ;AAEA,MAAIC,KAAK,GAAGN,YAAY,CAACO,MAAzB;AAAA,MACIC,IADJ;;AAEA,OAAKA,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGF,KAAtB,EAA6B,EAAEE,IAA/B,EAAqC;AACnCH,IAAAA,IAAI,GAAGL,YAAY,CAACQ,IAAD,CAAnB;AACAP,IAAAA,IAAI,GAAGD,YAAY,CAACQ,IAAI,GAAG,CAAR,CAAnB;AACA/B,IAAAA,UAAU,CAAC4B,IAAI,CAACvB,IAAN,EAAYmB,IAAI,CAAClB,IAAjB,EAAuBsB,IAAI,CAACtB,IAA5B,EAAkCY,MAAlC,CAAV;AACD;;AAEDM,EAAAA,IAAI,GAAGD,YAAY,CAAC,CAAD,CAAnB;AACAK,EAAAA,IAAI,GAAGL,YAAY,CAACM,KAAK,GAAG,CAAT,CAAnB;AACAD,EAAAA,IAAI,CAACvB,IAAL,GAAYN,UAAU,CAACyB,IAAI,CAAClB,IAAN,EAAYsB,IAAI,CAACtB,IAAjB,EAAuB,IAAvB,EAA6BY,MAA7B,CAAtB;AAEArB,EAAAA,YAAY,CAAC2B,IAAD,CAAZ;AACA3B,EAAAA,YAAY,CAAC+B,IAAD,CAAZ;AACD;AAED,OAAO,SAASI,QAAT,CAAkB1B,IAAlB,EAAwB;AAC7B,MAAIS,CAAC,GAAGT,IAAI,CAAC,CAAD,CAAZ;AAAA,MACI2B,SAAS,GAAG3B,IAAI,CAAC,CAAD,CADpB;AAAA,MAEIkB,IAFJ;AAAA,MAGII,IAHJ;AAAA,MAIIM,GAJJ;AAAA,MAKIC,GALJ;AAAA,MAMIC,IAAI,GAAGnC,OAAO,CAACoC,CANnB;;AAQA,SAAOD,IAAP,EAAa;AACXF,IAAAA,GAAG,GAAGI,cAAc,CAACF,IAAD,EAAOH,SAAP,CAAd,GAAkClB,CAAxC;AACA,QAAImB,GAAG,GAAGhC,OAAV,EAAmBkC,IAAI,GAAGA,IAAI,CAACG,CAAZ,CAAnB,KAAuC;AACrCJ,MAAAA,GAAG,GAAGpB,CAAC,GAAGyB,eAAe,CAACJ,IAAD,EAAOH,SAAP,CAAzB;;AACA,UAAIE,GAAG,GAAGjC,OAAV,EAAmB;AACjB,YAAI,CAACkC,IAAI,CAACK,CAAV,EAAa;AACXjB,UAAAA,IAAI,GAAGY,IAAP;AACA;AACD;;AACDA,QAAAA,IAAI,GAAGA,IAAI,CAACK,CAAZ;AACD,OAND,MAMO;AACL,YAAIP,GAAG,GAAG,CAAChC,OAAX,EAAoB;AAClBsB,UAAAA,IAAI,GAAGY,IAAI,CAAChB,CAAZ;AACAQ,UAAAA,IAAI,GAAGQ,IAAP;AACD,SAHD,MAGO,IAAID,GAAG,GAAG,CAACjC,OAAX,EAAoB;AACzBsB,UAAAA,IAAI,GAAGY,IAAP;AACAR,UAAAA,IAAI,GAAGQ,IAAI,CAACd,CAAZ;AACD,SAHM,MAGA;AACLE,UAAAA,IAAI,GAAGI,IAAI,GAAGQ,IAAd;AACD;;AACD;AACD;AACF;AACF;;AAEDxC,EAAAA,UAAU,CAACU,IAAD,CAAV;AACA,MAAIoC,MAAM,GAAGlC,WAAW,CAACF,IAAD,CAAxB;AACAL,EAAAA,OAAO,CAAC0C,MAAR,CAAenB,IAAf,EAAqBkB,MAArB;AAEA,MAAI,CAAClB,IAAD,IAAS,CAACI,IAAd,EAAoB;;AAEpB,MAAIJ,IAAI,KAAKI,IAAb,EAAmB;AACjB9B,IAAAA,YAAY,CAAC0B,IAAD,CAAZ;AACAI,IAAAA,IAAI,GAAGpB,WAAW,CAACgB,IAAI,CAAClB,IAAN,CAAlB;AACAL,IAAAA,OAAO,CAAC0C,MAAR,CAAeD,MAAf,EAAuBd,IAAvB;AACAc,IAAAA,MAAM,CAACrC,IAAP,GAAcuB,IAAI,CAACvB,IAAL,GAAYN,UAAU,CAACyB,IAAI,CAAClB,IAAN,EAAYoC,MAAM,CAACpC,IAAnB,CAApC;AACAT,IAAAA,YAAY,CAAC2B,IAAD,CAAZ;AACA3B,IAAAA,YAAY,CAAC+B,IAAD,CAAZ;AACA;AACD;;AAED,MAAI,CAACA,IAAL,EAAW;AAAE;AACXc,IAAAA,MAAM,CAACrC,IAAP,GAAcN,UAAU,CAACyB,IAAI,CAAClB,IAAN,EAAYoC,MAAM,CAACpC,IAAnB,CAAxB;AACA;AACD,GArD4B,CAuD7B;;;AACAR,EAAAA,YAAY,CAAC0B,IAAD,CAAZ;AACA1B,EAAAA,YAAY,CAAC8B,IAAD,CAAZ;AAEA,MAAIgB,KAAK,GAAGpB,IAAI,CAAClB,IAAjB;AAAA,MACIuC,EAAE,GAAGD,KAAK,CAAC,CAAD,CADd;AAAA,MAEIE,EAAE,GAAGF,KAAK,CAAC,CAAD,CAFd;AAAA,MAGIG,EAAE,GAAGzC,IAAI,CAAC,CAAD,CAAJ,GAAUuC,EAHnB;AAAA,MAIIG,EAAE,GAAG1C,IAAI,CAAC,CAAD,CAAJ,GAAUwC,EAJnB;AAAA,MAKIG,KAAK,GAAGrB,IAAI,CAACtB,IALjB;AAAA,MAMI4C,EAAE,GAAGD,KAAK,CAAC,CAAD,CAAL,GAAWJ,EANpB;AAAA,MAOI5B,EAAE,GAAGgC,KAAK,CAAC,CAAD,CAAL,GAAWH,EAPpB;AAAA,MAQIK,CAAC,GAAG,KAAKJ,EAAE,GAAG9B,EAAL,GAAU+B,EAAE,GAAGE,EAApB,CARR;AAAA,MASIE,EAAE,GAAGL,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EATxB;AAAA,MAUIK,EAAE,GAAGH,EAAE,GAAGA,EAAL,GAAUjC,EAAE,GAAGA,EAVxB;AAAA,MAWIC,MAAM,GAAG,CAAC,CAACD,EAAE,GAAGmC,EAAL,GAAUJ,EAAE,GAAGK,EAAhB,IAAsBF,CAAtB,GAA0BN,EAA3B,EAA+B,CAACE,EAAE,GAAGM,EAAL,GAAUH,EAAE,GAAGE,EAAhB,IAAsBD,CAAtB,GAA0BL,EAAzD,CAXb;AAaA9C,EAAAA,UAAU,CAAC4B,IAAI,CAACvB,IAAN,EAAYuC,KAAZ,EAAmBK,KAAnB,EAA0B/B,MAA1B,CAAV;AACAwB,EAAAA,MAAM,CAACrC,IAAP,GAAcN,UAAU,CAAC6C,KAAD,EAAQtC,IAAR,EAAc,IAAd,EAAoBY,MAApB,CAAxB;AACAU,EAAAA,IAAI,CAACvB,IAAL,GAAYN,UAAU,CAACO,IAAD,EAAO2C,KAAP,EAAc,IAAd,EAAoB/B,MAApB,CAAtB;AACArB,EAAAA,YAAY,CAAC2B,IAAD,CAAZ;AACA3B,EAAAA,YAAY,CAAC+B,IAAD,CAAZ;AACD;;AAED,SAASU,cAAT,CAAwBgB,GAAxB,EAA6BrB,SAA7B,EAAwC;AACtC,MAAI3B,IAAI,GAAGgD,GAAG,CAAChD,IAAf;AAAA,MACIiD,KAAK,GAAGjD,IAAI,CAAC,CAAD,CADhB;AAAA,MAEIkD,KAAK,GAAGlD,IAAI,CAAC,CAAD,CAFhB;AAAA,MAGImD,IAAI,GAAGD,KAAK,GAAGvB,SAHnB;AAKA,MAAI,CAACwB,IAAL,EAAW,OAAOF,KAAP;AAEX,MAAI/B,IAAI,GAAG8B,GAAG,CAAClC,CAAf;AACA,MAAI,CAACI,IAAL,EAAW,OAAO,CAACkC,QAAR;AAEXpD,EAAAA,IAAI,GAAGkB,IAAI,CAAClB,IAAZ;AACA,MAAIqD,KAAK,GAAGrD,IAAI,CAAC,CAAD,CAAhB;AAAA,MACIsD,KAAK,GAAGtD,IAAI,CAAC,CAAD,CADhB;AAAA,MAEIuD,KAAK,GAAGD,KAAK,GAAG3B,SAFpB;AAIA,MAAI,CAAC4B,KAAL,EAAY,OAAOF,KAAP;AAEZ,MAAIG,EAAE,GAAGH,KAAK,GAAGJ,KAAjB;AAAA,MACIQ,IAAI,GAAG,IAAIN,IAAJ,GAAW,IAAII,KAD1B;AAAA,MAEIG,CAAC,GAAGF,EAAE,GAAGD,KAFb;AAIA,MAAIE,IAAJ,EAAU,OAAO,CAAC,CAACC,CAAD,GAAKvC,IAAI,CAACwC,IAAL,CAAUD,CAAC,GAAGA,CAAJ,GAAQ,IAAID,IAAJ,IAAYD,EAAE,GAAGA,EAAL,IAAW,CAAC,CAAD,GAAKD,KAAhB,IAAyBD,KAAzB,GAAiCC,KAAK,GAAG,CAAzC,GAA6CL,KAA7C,GAAqDC,IAAI,GAAG,CAAxE,CAAlB,CAAN,IAAuGM,IAAvG,GAA8GR,KAArH;AAEV,SAAO,CAACA,KAAK,GAAGI,KAAT,IAAkB,CAAzB;AACD;;AAED,SAASnB,eAAT,CAAyBc,GAAzB,EAA8BrB,SAA9B,EAAyC;AACvC,MAAIL,IAAI,GAAG0B,GAAG,CAAChC,CAAf;AACA,MAAIM,IAAJ,EAAU,OAAOU,cAAc,CAACV,IAAD,EAAOK,SAAP,CAArB;AACV,MAAI3B,IAAI,GAAGgD,GAAG,CAAChD,IAAf;AACA,SAAOA,IAAI,CAAC,CAAD,CAAJ,KAAY2B,SAAZ,GAAwB3B,IAAI,CAAC,CAAD,CAA5B,GAAkCoD,QAAzC;AACD","sourcesContent":["import {RedBlackNode} from \"./RedBlackTree\";\nimport {createCell} from \"./Cell\";\nimport {attachCircle, detachCircle} from \"./Circle\";\nimport {createEdge, setEdgeEnd} from \"./Edge\";\nimport {beaches, epsilon} from \"./Diagram\";\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nexport function removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon\n      && Math.abs(y - lArc.circle.cy) < epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon\n      && Math.abs(y - rArc.circle.cy) < epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nexport function addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n"]},"metadata":{},"sourceType":"module"}