{"ast":null,"code":"import { addBeach, removeBeach } from \"./Beach\";\nimport { sortCellHalfedges, cellHalfedgeStart, clipCells } from \"./Cell\";\nimport { firstCircle } from \"./Circle\";\nimport { clipEdges } from \"./Edge\";\nimport RedBlackTree from \"./RedBlackTree\";\nexport var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var beaches;\nexport var cells;\nexport var circles;\nexport var edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1] || b[0] - a[0];\n}\n\nexport default function Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree();\n  circles = new RedBlackTree();\n\n  while (true) {\n    circle = firstCircle;\n\n    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n  beaches = circles = edges = cells = null;\n}\nDiagram.prototype = {\n  constructor: Diagram,\n  polygons: function polygons() {\n    var edges = this.edges;\n    return this.cells.map(function (cell) {\n      var polygon = cell.halfedges.map(function (i) {\n        return cellHalfedgeStart(cell, edges[i]);\n      });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n  triangles: function triangles() {\n    var triangles = [],\n        edges = this.edges;\n    this.cells.forEach(function (cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n    return triangles;\n  },\n  links: function links() {\n    return this.edges.filter(function (edge) {\n      return edge.right;\n    }).map(function (edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n  find: function find(x, y, radius) {\n    var that = this,\n        i0,\n        i1 = that._found || 0,\n        n = that.cells.length,\n        cell; // Use the previously-found cell, or start with an arbitrary one.\n\n    while (!(cell = that.cells[i1])) {\n      if (++i1 >= n) return null;\n    }\n\n    var dx = x - cell.site[0],\n        dy = y - cell.site[1],\n        d2 = dx * dx + dy * dy; // Traverse the half-edges to find a closer cell, if any.\n\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function (e) {\n        var edge = that.edges[e],\n            v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0],\n            vy = y - v[1],\n            v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n};","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-voronoi/src/Diagram.js"],"names":["addBeach","removeBeach","sortCellHalfedges","cellHalfedgeStart","clipCells","firstCircle","clipEdges","RedBlackTree","epsilon","epsilon2","beaches","cells","circles","edges","triangleArea","a","b","c","lexicographic","Diagram","sites","extent","site","sort","pop","x","y","circle","Array","length","arc","x0","y0","x1","y1","prototype","constructor","polygons","map","cell","polygon","halfedges","i","data","triangles","forEach","m","j","s0","e1","s1","left","right","index","push","links","filter","edge","source","target","find","radius","that","i0","i1","_found","n","dx","dy","d2","e","v","vx","vy","v2"],"mappings":"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","sourcesContent":["import {addBeach, removeBeach} from \"./Beach\";\nimport {sortCellHalfedges, cellHalfedgeStart, clipCells} from \"./Cell\";\nimport {firstCircle} from \"./Circle\";\nimport {clipEdges} from \"./Edge\";\nimport RedBlackTree from \"./RedBlackTree\";\n\nexport var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var beaches;\nexport var cells;\nexport var circles;\nexport var edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nexport default function Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}