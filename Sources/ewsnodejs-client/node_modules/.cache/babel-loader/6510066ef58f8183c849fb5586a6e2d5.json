{"ast":null,"code":"export default function (x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1; // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  } // Otherwise, double repeatedly to cover.\n  else {\n      var z = x1 - x0,\n          node = this._root,\n          parent,\n          i;\n\n      while (x0 > x || x >= x1 || y0 > y || y >= y1) {\n        i = (y < y0) << 1 | x < x0;\n        parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n\n        switch (i) {\n          case 0:\n            x1 = x0 + z, y1 = y0 + z;\n            break;\n\n          case 1:\n            x0 = x1 - z, y1 = y0 + z;\n            break;\n\n          case 2:\n            x1 = x0 + z, y0 = y1 - z;\n            break;\n\n          case 3:\n            x0 = x1 - z, y0 = y1 - z;\n            break;\n        }\n      }\n\n      if (this._root && this._root.length) this._root = node;\n    }\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-quadtree/src/cover.js"],"names":["x","y","isNaN","x0","_x0","y0","_y0","x1","_x1","y1","_y1","Math","floor","z","node","_root","parent","i","Array","length"],"mappings":"AAAA,eAAe,UAASA,CAAT,EAAYC,CAAZ,EAAe;AAC5B,MAAIC,KAAK,CAACF,CAAC,GAAG,CAACA,CAAN,CAAL,IAAiBE,KAAK,CAACD,CAAC,GAAG,CAACA,CAAN,CAA1B,EAAoC,OAAO,IAAP,CADR,CACqB;;AAEjD,MAAIE,EAAE,GAAG,KAAKC,GAAd;AAAA,MACIC,EAAE,GAAG,KAAKC,GADd;AAAA,MAEIC,EAAE,GAAG,KAAKC,GAFd;AAAA,MAGIC,EAAE,GAAG,KAAKC,GAHd,CAH4B,CAQ5B;AACA;AACA;;AACA,MAAIR,KAAK,CAACC,EAAD,CAAT,EAAe;AACbI,IAAAA,EAAE,GAAG,CAACJ,EAAE,GAAGQ,IAAI,CAACC,KAAL,CAAWZ,CAAX,CAAN,IAAuB,CAA5B;AACAS,IAAAA,EAAE,GAAG,CAACJ,EAAE,GAAGM,IAAI,CAACC,KAAL,CAAWX,CAAX,CAAN,IAAuB,CAA5B;AACD,GAHD,CAKA;AALA,OAMK;AACH,UAAIY,CAAC,GAAGN,EAAE,GAAGJ,EAAb;AAAA,UACIW,IAAI,GAAG,KAAKC,KADhB;AAAA,UAEIC,MAFJ;AAAA,UAGIC,CAHJ;;AAKA,aAAOd,EAAE,GAAGH,CAAL,IAAUA,CAAC,IAAIO,EAAf,IAAqBF,EAAE,GAAGJ,CAA1B,IAA+BA,CAAC,IAAIQ,EAA3C,EAA+C;AAC7CQ,QAAAA,CAAC,GAAG,CAAChB,CAAC,GAAGI,EAAL,KAAY,CAAZ,GAAiBL,CAAC,GAAGG,EAAzB;AACAa,QAAAA,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,EAAwDH,CAAC,IAAI,CAA7D;;AACA,gBAAQI,CAAR;AACE,eAAK,CAAL;AAAQV,YAAAA,EAAE,GAAGJ,EAAE,GAAGU,CAAV,EAAaJ,EAAE,GAAGJ,EAAE,GAAGQ,CAAvB;AAA0B;;AAClC,eAAK,CAAL;AAAQV,YAAAA,EAAE,GAAGI,EAAE,GAAGM,CAAV,EAAaJ,EAAE,GAAGJ,EAAE,GAAGQ,CAAvB;AAA0B;;AAClC,eAAK,CAAL;AAAQN,YAAAA,EAAE,GAAGJ,EAAE,GAAGU,CAAV,EAAaR,EAAE,GAAGI,EAAE,GAAGI,CAAvB;AAA0B;;AAClC,eAAK,CAAL;AAAQV,YAAAA,EAAE,GAAGI,EAAE,GAAGM,CAAV,EAAaR,EAAE,GAAGI,EAAE,GAAGI,CAAvB;AAA0B;AAJpC;AAMD;;AAED,UAAI,KAAKE,KAAL,IAAc,KAAKA,KAAL,CAAWI,MAA7B,EAAqC,KAAKJ,KAAL,GAAaD,IAAb;AACtC;;AAED,OAAKV,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,SAAO,IAAP;AACD","sourcesContent":["export default function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    while (x0 > x || x >= x1 || y0 > y || y >= y1) {\n      i = (y < y0) << 1 | (x < x0);\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0: x1 = x0 + z, y1 = y0 + z; break;\n        case 1: x0 = x1 - z, y1 = y0 + z; break;\n        case 2: x1 = x0 + z, y0 = y1 - z; break;\n        case 3: x0 = x1 - z, y0 = y1 - z; break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}