{"ast":null,"code":"export default function (d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j; // If the tree is empty, initialize the root as a leaf.\n\n  if (!node) return this; // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;\n  } // Find the point to remove.\n\n  while (node.data !== d) {\n    if (!(previous = node, node = node.next)) return this;\n  }\n\n  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.\n\n  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.\n\n  if (!parent) return this._root = next, this; // Remove this leaf.\n\n  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.\n\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {\n    if (retainer) retainer[j] = node;else this._root = node;\n  }\n\n  return this;\n}\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) {\n    this.remove(data[i]);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-quadtree/src/remove.js"],"names":["d","isNaN","x","_x","call","y","_y","parent","node","_root","retainer","previous","next","x0","_x0","y0","_y0","x1","_x1","y1","_y1","xm","ym","right","bottom","i","j","length","data","removeAll","n","remove"],"mappings":"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","sourcesContent":["export default function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n}\n\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}