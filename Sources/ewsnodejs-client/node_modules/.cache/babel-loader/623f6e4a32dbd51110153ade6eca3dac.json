{"ast":null,"code":"import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport { quadtree } from \"d3-quadtree\";\nimport { x, y } from \"./simulation\";\nexport default function () {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i,\n        n = nodes.length,\n        tree = quadtree(nodes, x, y).visitAfter(accumulate);\n\n    for (alpha = _, i = 0; i < n; ++i) {\n      node = nodes[i], tree.visit(apply);\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i,\n        n = nodes.length,\n        node;\n    strengths = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n    }\n  }\n\n  function accumulate(quad) {\n    var strength = 0,\n        q,\n        c,\n        weight = 0,\n        x,\n        y,\n        i; // For internal nodes, accumulate forces from child quadrants.\n\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n\n      quad.x = x / weight;\n      quad.y = y / weight;\n    } // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n        q = quad;\n        q.x = q.data.x;\n        q.y = q.data.y;\n\n        do {\n          strength += strengths[q.data.index];\n        } while (q = q.next);\n      }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y; // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n\n      return true;\n    } // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident.\n\n\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do {\n      if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x * w;\n        node.vy += y * w;\n      }\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function (_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function (_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function (_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function (_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function (_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-force/src/manyBody.js"],"names":["constant","jiggle","quadtree","x","y","nodes","node","alpha","strength","strengths","distanceMin2","distanceMax2","Infinity","theta2","force","_","i","n","length","tree","visitAfter","accumulate","visit","apply","initialize","Array","index","quad","q","c","weight","Math","abs","value","data","next","x1","x2","w","l","sqrt","vx","vy","arguments","distanceMin","distanceMax","theta"],"mappings":"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","sourcesContent":["import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {quadtree} from \"d3-quadtree\";\nimport {x, y} from \"./simulation\";\n\nexport default function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, weight = 0, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / weight;\n      quad.y = y / weight;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}\n"]},"metadata":{},"sourceType":"module"}