{"ast":null,"code":"import pointEqual from \"../pointEqual.js\";\nimport { epsilon } from \"../math.js\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n\n  this.e = entry; // is an entry?\n\n  this.v = false; // visited\n\n  this.n = this.p = null; // next & previous\n} // A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\n\n\nexport default function (segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n  segments.forEach(function (segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n,\n        p0 = segment[0],\n        p1 = segment[n],\n        x;\n\n    if (pointEqual(p0, p1)) {\n      if (!p0[2] && !p1[2]) {\n        stream.lineStart();\n\n        for (i = 0; i < n; ++i) {\n          stream.point((p0 = segment[i])[0], p0[1]);\n        }\n\n        stream.lineEnd();\n        return;\n      } // handle degenerate cases by moving the point\n\n\n      p1[0] += 2 * epsilon;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n  if (!subject.length) return;\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n\n    while (current.v) {\n      if ((current = current.n) === start) return;\n    }\n\n    points = current.z;\n    stream.lineStart();\n\n    do {\n      current.v = current.o.v = true;\n\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n\n          for (i = points.length - 1; i >= 0; --i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n\n        current = current.p;\n      }\n\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n\n  a.n = b = array[0];\n  b.p = a;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-geo/src/clip/rejoin.js"],"names":["pointEqual","epsilon","Intersection","point","points","other","entry","x","z","o","e","v","n","p","segments","compareIntersection","startInside","interpolate","stream","subject","clip","i","forEach","segment","length","p0","p1","lineStart","lineEnd","push","sort","link","start","current","isSubject","array","a","b"],"mappings":"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","sourcesContent":["import pointEqual from \"../pointEqual.js\";\nimport {epsilon} from \"../math.js\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    if (pointEqual(p0, p1)) {\n      if (!p0[2] && !p1[2]) {\n        stream.lineStart();\n        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n        stream.lineEnd();\n        return;\n      }\n      // handle degenerate cases by moving the point\n      p1[0] += 2 * epsilon;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n"]},"metadata":{},"sourceType":"module"}