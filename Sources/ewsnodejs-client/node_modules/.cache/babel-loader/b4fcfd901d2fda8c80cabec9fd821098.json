{"ast":null,"code":"import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\nexport var phi = (1 + Math.sqrt(5)) / 2;\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx,\n      dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.\n\n    do {\n      sumValue = nodes[i1++].value;\n    } while (!sumValue && i1 < n);\n\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.\n\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n\n      if (newRatio > minRatio) {\n        sumValue -= nodeValue;\n        break;\n      }\n\n      minRatio = newRatio;\n    } // Position and record the row orientation.\n\n\n    rows.push(row = {\n      value: sumValue,\n      dice: dx < dy,\n      children: nodes.slice(i0, i1)\n    });\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\nexport default (function custom(ratio) {\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function (x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-hierarchy/src/treemap/squarify.js"],"names":["treemapDice","treemapSlice","phi","Math","sqrt","squarifyRatio","ratio","parent","x0","y0","x1","y1","rows","nodes","children","row","nodeValue","i0","i1","n","length","dx","dy","value","sumValue","minValue","maxValue","newRatio","minRatio","alpha","beta","max","push","dice","slice","custom","squarify","x"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,WAAxB;AACA,OAAOC,YAAP,MAAyB,YAAzB;AAEA,OAAO,IAAIC,GAAG,GAAG,CAAC,IAAIC,IAAI,CAACC,IAAL,CAAU,CAAV,CAAL,IAAqB,CAA/B;AAEP,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,MAA9B,EAAsCC,EAAtC,EAA0CC,EAA1C,EAA8CC,EAA9C,EAAkDC,EAAlD,EAAsD;AAC3D,MAAIC,IAAI,GAAG,EAAX;AAAA,MACIC,KAAK,GAAGN,MAAM,CAACO,QADnB;AAAA,MAEIC,GAFJ;AAAA,MAGIC,SAHJ;AAAA,MAIIC,EAAE,GAAG,CAJT;AAAA,MAKIC,EAAE,GAAG,CALT;AAAA,MAMIC,CAAC,GAAGN,KAAK,CAACO,MANd;AAAA,MAOIC,EAPJ;AAAA,MAOQC,EAPR;AAAA,MAQIC,KAAK,GAAGhB,MAAM,CAACgB,KARnB;AAAA,MASIC,QATJ;AAAA,MAUIC,QAVJ;AAAA,MAWIC,QAXJ;AAAA,MAYIC,QAZJ;AAAA,MAaIC,QAbJ;AAAA,MAcIC,KAdJ;AAAA,MAeIC,IAfJ;;AAiBA,SAAOb,EAAE,GAAGE,CAAZ,EAAe;AACbE,IAAAA,EAAE,GAAGX,EAAE,GAAGF,EAAV,EAAcc,EAAE,GAAGX,EAAE,GAAGF,EAAxB,CADa,CAGb;;AACA;AAAGe,MAAAA,QAAQ,GAAGX,KAAK,CAACK,EAAE,EAAH,CAAL,CAAYK,KAAvB;AAAH,aAAwC,CAACC,QAAD,IAAaN,EAAE,GAAGC,CAA1D;;AACAM,IAAAA,QAAQ,GAAGC,QAAQ,GAAGF,QAAtB;AACAK,IAAAA,KAAK,GAAG1B,IAAI,CAAC4B,GAAL,CAAST,EAAE,GAAGD,EAAd,EAAkBA,EAAE,GAAGC,EAAvB,KAA8BC,KAAK,GAAGjB,KAAtC,CAAR;AACAwB,IAAAA,IAAI,GAAGN,QAAQ,GAAGA,QAAX,GAAsBK,KAA7B;AACAD,IAAAA,QAAQ,GAAGzB,IAAI,CAAC4B,GAAL,CAASL,QAAQ,GAAGI,IAApB,EAA0BA,IAAI,GAAGL,QAAjC,CAAX,CARa,CAUb;;AACA,WAAOP,EAAE,GAAGC,CAAZ,EAAe,EAAED,EAAjB,EAAqB;AACnBM,MAAAA,QAAQ,IAAIR,SAAS,GAAGH,KAAK,CAACK,EAAD,CAAL,CAAUK,KAAlC;AACA,UAAIP,SAAS,GAAGS,QAAhB,EAA0BA,QAAQ,GAAGT,SAAX;AAC1B,UAAIA,SAAS,GAAGU,QAAhB,EAA0BA,QAAQ,GAAGV,SAAX;AAC1Bc,MAAAA,IAAI,GAAGN,QAAQ,GAAGA,QAAX,GAAsBK,KAA7B;AACAF,MAAAA,QAAQ,GAAGxB,IAAI,CAAC4B,GAAL,CAASL,QAAQ,GAAGI,IAApB,EAA0BA,IAAI,GAAGL,QAAjC,CAAX;;AACA,UAAIE,QAAQ,GAAGC,QAAf,EAAyB;AAAEJ,QAAAA,QAAQ,IAAIR,SAAZ;AAAuB;AAAQ;;AAC1DY,MAAAA,QAAQ,GAAGD,QAAX;AACD,KAnBY,CAqBb;;;AACAf,IAAAA,IAAI,CAACoB,IAAL,CAAUjB,GAAG,GAAG;AAACQ,MAAAA,KAAK,EAAEC,QAAR;AAAkBS,MAAAA,IAAI,EAAEZ,EAAE,GAAGC,EAA7B;AAAiCR,MAAAA,QAAQ,EAAED,KAAK,CAACqB,KAAN,CAAYjB,EAAZ,EAAgBC,EAAhB;AAA3C,KAAhB;AACA,QAAIH,GAAG,CAACkB,IAAR,EAAcjC,WAAW,CAACe,GAAD,EAAMP,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBa,KAAK,GAAGd,EAAE,IAAIa,EAAE,GAAGE,QAAL,GAAgBD,KAAzB,GAAiCZ,EAAxD,CAAX,CAAd,KACKV,YAAY,CAACc,GAAD,EAAMP,EAAN,EAAUC,EAAV,EAAcc,KAAK,GAAGf,EAAE,IAAIa,EAAE,GAAGG,QAAL,GAAgBD,KAAzB,GAAiCb,EAApD,EAAwDC,EAAxD,CAAZ;AACLY,IAAAA,KAAK,IAAIC,QAAT,EAAmBP,EAAE,GAAGC,EAAxB;AACD;;AAED,SAAON,IAAP;AACD;AAED,eAAe,CAAC,SAASuB,MAAT,CAAgB7B,KAAhB,EAAuB;AAErC,WAAS8B,QAAT,CAAkB7B,MAAlB,EAA0BC,EAA1B,EAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0C;AACxCN,IAAAA,aAAa,CAACC,KAAD,EAAQC,MAAR,EAAgBC,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB,EAA4BC,EAA5B,CAAb;AACD;;AAEDyB,EAAAA,QAAQ,CAAC9B,KAAT,GAAiB,UAAS+B,CAAT,EAAY;AAC3B,WAAOF,MAAM,CAAC,CAACE,CAAC,GAAG,CAACA,CAAN,IAAW,CAAX,GAAeA,CAAf,GAAmB,CAApB,CAAb;AACD,GAFD;;AAIA,SAAOD,QAAP;AACD,CAXc,EAWZlC,GAXY,CAAf","sourcesContent":["import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n"]},"metadata":{},"sourceType":"module"}