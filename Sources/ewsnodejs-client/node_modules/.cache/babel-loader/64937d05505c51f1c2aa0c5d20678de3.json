{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AtomicBlockUtils\n * @format\n * \n */\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\n\nvar CharacterMetadata = require('./CharacterMetadata');\n\nvar ContentBlock = require('./ContentBlock');\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\n\nvar DraftModifier = require('./DraftModifier');\n\nvar EditorState = require('./EditorState');\n\nvar Immutable = require('immutable');\n\nvar SelectionState = require('./SelectionState');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar moveBlockInContentState = require('./moveBlockInContentState');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\nvar ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;\nvar List = Immutable.List,\n    Repeat = Immutable.Repeat;\nvar AtomicBlockUtils = {\n  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n    var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');\n    var targetSelection = afterRemoval.getSelectionAfter();\n    var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);\n    var insertionTarget = afterSplit.getSelectionAfter();\n    var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');\n    var charData = CharacterMetadata.create({\n      entity: entityKey\n    });\n    var atomicBlockConfig = {\n      key: generateRandomKey(),\n      type: 'atomic',\n      text: character,\n      characterList: List(Repeat(charData, character.length))\n    };\n    var atomicDividerBlockConfig = {\n      key: generateRandomKey(),\n      type: 'unstyled'\n    };\n\n    if (experimentalTreeDataSupport) {\n      atomicBlockConfig = _extends({}, atomicBlockConfig, {\n        nextSibling: atomicDividerBlockConfig.key\n      });\n      atomicDividerBlockConfig = _extends({}, atomicDividerBlockConfig, {\n        prevSibling: atomicBlockConfig.key\n      });\n    }\n\n    var fragmentArray = [new ContentBlockRecord(atomicBlockConfig), new ContentBlockRecord(atomicDividerBlockConfig)];\n    var fragment = BlockMapBuilder.createFromArray(fragmentArray);\n    var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);\n    var newContent = withAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n    return EditorState.push(editorState, newContent, 'insert-fragment');\n  },\n  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n    var withMovedAtomicBlock = void 0;\n\n    if (insertionMode === 'before' || insertionMode === 'after') {\n      var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());\n      withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);\n    } else {\n      var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');\n      var selectionAfterRemoval = afterRemoval.getSelectionAfter();\n\n      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());\n\n      if (selectionAfterRemoval.getStartOffset() === 0) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');\n      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');\n      } else {\n        var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);\n        var selectionAfterSplit = afterSplit.getSelectionAfter();\n\n        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());\n\n        withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');\n      }\n    }\n\n    var newContent = withMovedAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n    return EditorState.push(editorState, newContent, 'move-block');\n  }\n};\nmodule.exports = AtomicBlockUtils;","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/draft-js/lib/AtomicBlockUtils.js"],"names":["_assign","require","_extends","target","i","arguments","length","source","key","Object","prototype","hasOwnProperty","call","BlockMapBuilder","CharacterMetadata","ContentBlock","ContentBlockNode","DraftFeatureFlags","DraftModifier","EditorState","Immutable","SelectionState","generateRandomKey","moveBlockInContentState","experimentalTreeDataSupport","draft_tree_data_support","ContentBlockRecord","List","Repeat","AtomicBlockUtils","insertAtomicBlock","editorState","entityKey","character","contentState","getCurrentContent","selectionState","getSelection","afterRemoval","removeRange","targetSelection","getSelectionAfter","afterSplit","splitBlock","insertionTarget","asAtomicBlock","setBlockType","charData","create","entity","atomicBlockConfig","type","text","characterList","atomicDividerBlockConfig","nextSibling","prevSibling","fragmentArray","fragment","createFromArray","withAtomicBlock","replaceWithFragment","newContent","merge","selectionBefore","selectionAfter","set","push","moveAtomicBlock","atomicBlock","targetRange","insertionMode","withMovedAtomicBlock","targetBlock","getBlockForKey","getStartKey","getEndKey","selectionAfterRemoval","_targetBlock","getFocusKey","getStartOffset","getEndOffset","getLength","selectionAfterSplit","_targetBlock2","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AtomicBlockUtils\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar CharacterMetadata = require('./CharacterMetadata');\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftModifier = require('./DraftModifier');\nvar EditorState = require('./EditorState');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar generateRandomKey = require('./generateRandomKey');\nvar moveBlockInContentState = require('./moveBlockInContentState');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\nvar ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;\n\nvar List = Immutable.List,\n    Repeat = Immutable.Repeat;\n\n\nvar AtomicBlockUtils = {\n  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n\n    var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');\n\n    var targetSelection = afterRemoval.getSelectionAfter();\n    var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);\n    var insertionTarget = afterSplit.getSelectionAfter();\n\n    var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');\n\n    var charData = CharacterMetadata.create({ entity: entityKey });\n\n    var atomicBlockConfig = {\n      key: generateRandomKey(),\n      type: 'atomic',\n      text: character,\n      characterList: List(Repeat(charData, character.length))\n    };\n\n    var atomicDividerBlockConfig = {\n      key: generateRandomKey(),\n      type: 'unstyled'\n    };\n\n    if (experimentalTreeDataSupport) {\n      atomicBlockConfig = _extends({}, atomicBlockConfig, {\n        nextSibling: atomicDividerBlockConfig.key\n      });\n      atomicDividerBlockConfig = _extends({}, atomicDividerBlockConfig, {\n        prevSibling: atomicBlockConfig.key\n      });\n    }\n\n    var fragmentArray = [new ContentBlockRecord(atomicBlockConfig), new ContentBlockRecord(atomicDividerBlockConfig)];\n\n    var fragment = BlockMapBuilder.createFromArray(fragmentArray);\n\n    var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);\n\n    var newContent = withAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n\n    return EditorState.push(editorState, newContent, 'insert-fragment');\n  },\n\n  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n\n    var withMovedAtomicBlock = void 0;\n\n    if (insertionMode === 'before' || insertionMode === 'after') {\n      var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());\n\n      withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);\n    } else {\n      var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');\n\n      var selectionAfterRemoval = afterRemoval.getSelectionAfter();\n      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());\n\n      if (selectionAfterRemoval.getStartOffset() === 0) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');\n      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');\n      } else {\n        var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);\n\n        var selectionAfterSplit = afterSplit.getSelectionAfter();\n        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());\n\n        withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');\n      }\n    }\n\n    var newContent = withMovedAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n\n    return EditorState.push(editorState, newContent, 'move-block');\n  }\n};\n\nmodule.exports = AtomicBlockUtils;"]},"metadata":{},"sourceType":"script"}