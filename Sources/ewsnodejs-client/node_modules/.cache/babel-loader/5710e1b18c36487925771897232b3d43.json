{"ast":null,"code":"import { dispatch } from \"d3-dispatch\";\nimport { timer, timeout } from \"d3-timer\";\nvar emptyOn = dispatch(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\nexport default function (node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index,\n    // For context during callback.\n    group: group,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween; // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.\n\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.\n\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n\n      if (o.state === STARTED) return timeout(start); // Interrupt the active transition, if any.\n\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } // Cancel any pre-empted transitions.\n      else if (+i < id) {\n          o.state = ENDED;\n          o.timer.stop();\n          o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n          delete schedules[i];\n        }\n    } // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n\n\n    timeout(function () {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    }); // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n\n    self.state = STARTED; // Initialize the tween, deleting null tween.\n\n    tween = new Array(n = self.tween.length);\n\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(node, t);\n    } // Dispatch the end event.\n\n\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n\n    for (var i in schedules) {\n      return;\n    } // eslint-disable-line no-unused-vars\n\n\n    delete node.__transition;\n  }\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-transition/src/transition/schedule.js"],"names":["dispatch","timer","timeout","emptyOn","emptyTween","CREATED","SCHEDULED","STARTING","STARTED","RUNNING","ENDING","ENDED","node","name","id","index","group","timing","schedules","__transition","create","on","tween","time","delay","duration","ease","state","init","schedule","get","Error","set","self","elapsed","restart","start","i","j","n","o","stop","call","__data__","tick","Array","length","value","t"],"mappings":"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","sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer, timeout} from \"d3-timer\";\n\nvar emptyOn = dispatch(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\n\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\n\nexport default function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\n\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\n\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\n\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout(start);\n\n      // Interrupt the active transition, if any.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions.\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}