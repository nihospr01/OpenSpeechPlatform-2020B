{"ast":null,"code":"import { Selection } from \"./index\";\nimport { EnterNode } from \"./enter\";\nimport constant from \"../constant\";\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length; // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Put any non-null nodes that don’t fit into exit.\n\n\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue; // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  } // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n\n\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Add any remaining nodes that were not bound to data to exit.\n\n\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function (value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function (d) {\n      data[++j] = d;\n    });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {\n          ;\n        }\n\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-selection/src/selection/data.js"],"names":["Selection","EnterNode","constant","keyPrefix","bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","length","dataLength","__data__","bindKey","key","nodeByKeyValue","keyValues","Array","keyValue","call","value","size","j","each","d","bind","parents","_parents","groups","_groups","m","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","_next","_enter","_exit"],"mappings":"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","sourcesContent":["import {Selection} from \"./index\";\nimport {EnterNode} from \"./enter\";\nimport constant from \"../constant\";\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n"]},"metadata":{},"sourceType":"module"}