{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromRawToDraftState\n * @format\n * \n */\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar ContentBlock = require('./ContentBlock');\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar ContentState = require('./ContentState');\n\nvar DraftEntity = require('./DraftEntity');\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\n\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\n\nvar Immutable = require('immutable');\n\nvar SelectionState = require('./SelectionState');\n\nvar createCharacterList = require('./createCharacterList');\n\nvar decodeEntityRanges = require('./decodeEntityRanges');\n\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\nvar List = Immutable.List,\n    Map = Immutable.Map,\n    OrderedMap = Immutable.OrderedMap;\n\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\n  var key = block.key,\n      type = block.type,\n      data = block.data,\n      text = block.text,\n      depth = block.depth;\n  var blockNodeConfig = {\n    text: text,\n    depth: depth || 0,\n    type: type || 'unstyled',\n    key: key || generateRandomKey(),\n    data: Map(data),\n    characterList: decodeCharacterList(block, entityMap)\n  };\n  return blockNodeConfig;\n};\n\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\n  var text = block.text,\n      rawEntityRanges = block.entityRanges,\n      rawInlineStyleRanges = block.inlineStyleRanges;\n  var entityRanges = rawEntityRanges || [];\n  var inlineStyleRanges = rawInlineStyleRanges || []; // Translate entity range keys to the DraftEntity map.\n\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\n    return entityMap.hasOwnProperty(range.key);\n  }).map(function (range) {\n    return _extends({}, range, {\n      key: entityMap[range.key]\n    });\n  })));\n};\n\nvar addKeyIfMissing = function addKeyIfMissing(block) {\n  return _extends({}, block, {\n    key: block.key || generateRandomKey()\n  });\n};\n/**\n * Node stack is responsible to ensure we traverse the tree only once\n * in depth order, while also providing parent refs to inner nodes to\n * construct their links.\n */\n\n\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\n  var nodesWithParentRef = nodes.map(function (block) {\n    return _extends({}, block, {\n      parentRef: parentRef\n    });\n  }); // since we pop nodes from the stack we need to insert them in reverse\n\n  return stack.concat(nodesWithParentRef.reverse());\n};\n/**\n * This will build a tree draft content state by creating the node\n * reference links into a single tree walk. Each node has a link\n * reference to \"parent\", \"children\", \"nextSibling\" and \"prevSibling\"\n * blockMap will be created using depth ordering.\n */\n\n\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\n  return blocks // ensure children have valid keys to enable sibling links\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0; // ensure children have valid keys to enable sibling links\n\n    var children = block.children.map(addKeyIfMissing); // root level nodes\n\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\n      children: List(children.map(function (child) {\n        return child.key;\n      }))\n    })); // push root node to blockMap\n\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode); // this stack is used to ensure we visit all nodes respecting depth ordering\n\n    var stack = updateNodeStack([], children, contentBlockNode); // start computing children nodes\n\n    while (stack.length > 0) {\n      // we pop from the stack and start processing this node\n      var node = stack.pop(); // parentRef already points to a converted ContentBlockNode\n\n      var parentRef = node.parentRef;\n      var siblings = parentRef.getChildKeys();\n\n      var _index = siblings.indexOf(node.key);\n\n      var isValidBlock = Array.isArray(node.children);\n\n      if (!isValidBlock) {\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n        break;\n      } // ensure children have valid keys to enable sibling links\n\n\n      var _children = node.children.map(addKeyIfMissing);\n\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\n        parent: parentRef.getKey(),\n        children: List(_children.map(function (child) {\n          return child.key;\n        })),\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\n      })); // push node to blockMap\n\n\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode); // this stack is used to ensure we visit all nodes respecting depth ordering\n\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\n    }\n\n    return blockMap;\n  }, OrderedMap());\n};\n\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\n  return OrderedMap(blocks.map(function (block) {\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\n    return [contentBlock.getKey(), contentBlock];\n  }));\n};\n\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\n\n  if (!experimentalTreeDataSupport) {\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\n  }\n\n  return decodeContentBlockNodes(rawBlocks, entityMap);\n};\n\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\n  var rawEntityMap = rawState.entityMap;\n  var entityMap = {}; // TODO: Update this once we completely remove DraftEntity\n\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\n        type = _rawEntityMap$rawEnti.type,\n        mutability = _rawEntityMap$rawEnti.mutability,\n        data = _rawEntityMap$rawEnti.data; // get the key reference to created entity\n\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\n  });\n  return entityMap;\n};\n\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0; // decode entities\n\n  var entityMap = decodeRawEntityMap(rawState); // decode blockMap\n\n  var blockMap = decodeRawBlocks(rawState, entityMap); // create initial selection\n\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\n  return new ContentState({\n    blockMap: blockMap,\n    entityMap: entityMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\n\nmodule.exports = convertFromRawToDraftState;","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/draft-js/lib/convertFromRawToDraftState.js"],"names":["_assign","require","_extends","target","i","arguments","length","source","key","Object","prototype","hasOwnProperty","call","ContentBlock","ContentBlockNode","ContentState","DraftEntity","DraftFeatureFlags","DraftTreeAdapter","Immutable","SelectionState","createCharacterList","decodeEntityRanges","decodeInlineStyleRanges","generateRandomKey","invariant","experimentalTreeDataSupport","draft_tree_data_support","List","Map","OrderedMap","decodeBlockNodeConfig","block","entityMap","type","data","text","depth","blockNodeConfig","characterList","decodeCharacterList","rawEntityRanges","entityRanges","rawInlineStyleRanges","inlineStyleRanges","filter","range","map","addKeyIfMissing","updateNodeStack","stack","nodes","parentRef","nodesWithParentRef","concat","reverse","decodeContentBlockNodes","blocks","reduce","blockMap","index","Array","isArray","children","process","env","NODE_ENV","contentBlockNode","prevSibling","nextSibling","child","set","getKey","node","pop","siblings","getChildKeys","_index","indexOf","isValidBlock","_children","_contentBlockNode","parent","get","size","decodeContentBlocks","contentBlock","decodeRawBlocks","rawState","isTreeRawBlock","rawBlocks","fromRawStateToRawTreeState","fromRawTreeStateToRawState","decodeRawEntityMap","rawEntityMap","keys","forEach","rawEntityKey","_rawEntityMap$rawEnti","mutability","__create","convertFromRawToDraftState","selectionState","isEmpty","createEmpty","first","selectionBefore","selectionAfter","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromRawToDraftState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar ContentState = require('./ContentState');\nvar DraftEntity = require('./DraftEntity');\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar createCharacterList = require('./createCharacterList');\nvar decodeEntityRanges = require('./decodeEntityRanges');\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\nvar generateRandomKey = require('./generateRandomKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\n\nvar List = Immutable.List,\n    Map = Immutable.Map,\n    OrderedMap = Immutable.OrderedMap;\n\n\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\n  var key = block.key,\n      type = block.type,\n      data = block.data,\n      text = block.text,\n      depth = block.depth;\n\n\n  var blockNodeConfig = {\n    text: text,\n    depth: depth || 0,\n    type: type || 'unstyled',\n    key: key || generateRandomKey(),\n    data: Map(data),\n    characterList: decodeCharacterList(block, entityMap)\n  };\n\n  return blockNodeConfig;\n};\n\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\n  var text = block.text,\n      rawEntityRanges = block.entityRanges,\n      rawInlineStyleRanges = block.inlineStyleRanges;\n\n\n  var entityRanges = rawEntityRanges || [];\n  var inlineStyleRanges = rawInlineStyleRanges || [];\n\n  // Translate entity range keys to the DraftEntity map.\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\n    return entityMap.hasOwnProperty(range.key);\n  }).map(function (range) {\n    return _extends({}, range, { key: entityMap[range.key] });\n  })));\n};\n\nvar addKeyIfMissing = function addKeyIfMissing(block) {\n  return _extends({}, block, {\n    key: block.key || generateRandomKey()\n  });\n};\n\n/**\n * Node stack is responsible to ensure we traverse the tree only once\n * in depth order, while also providing parent refs to inner nodes to\n * construct their links.\n */\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\n  var nodesWithParentRef = nodes.map(function (block) {\n    return _extends({}, block, {\n      parentRef: parentRef\n    });\n  });\n\n  // since we pop nodes from the stack we need to insert them in reverse\n  return stack.concat(nodesWithParentRef.reverse());\n};\n\n/**\n * This will build a tree draft content state by creating the node\n * reference links into a single tree walk. Each node has a link\n * reference to \"parent\", \"children\", \"nextSibling\" and \"prevSibling\"\n * blockMap will be created using depth ordering.\n */\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\n  return blocks\n  // ensure children have valid keys to enable sibling links\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n\n    // ensure children have valid keys to enable sibling links\n    var children = block.children.map(addKeyIfMissing);\n\n    // root level nodes\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\n      children: List(children.map(function (child) {\n        return child.key;\n      }))\n    }));\n\n    // push root node to blockMap\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);\n\n    // this stack is used to ensure we visit all nodes respecting depth ordering\n    var stack = updateNodeStack([], children, contentBlockNode);\n\n    // start computing children nodes\n    while (stack.length > 0) {\n      // we pop from the stack and start processing this node\n      var node = stack.pop();\n\n      // parentRef already points to a converted ContentBlockNode\n      var parentRef = node.parentRef;\n      var siblings = parentRef.getChildKeys();\n      var _index = siblings.indexOf(node.key);\n      var isValidBlock = Array.isArray(node.children);\n\n      if (!isValidBlock) {\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n        break;\n      }\n\n      // ensure children have valid keys to enable sibling links\n      var _children = node.children.map(addKeyIfMissing);\n\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\n        parent: parentRef.getKey(),\n        children: List(_children.map(function (child) {\n          return child.key;\n        })),\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\n      }));\n\n      // push node to blockMap\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);\n\n      // this stack is used to ensure we visit all nodes respecting depth ordering\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\n    }\n\n    return blockMap;\n  }, OrderedMap());\n};\n\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\n  return OrderedMap(blocks.map(function (block) {\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\n    return [contentBlock.getKey(), contentBlock];\n  }));\n};\n\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\n\n  if (!experimentalTreeDataSupport) {\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\n  }\n\n  return decodeContentBlockNodes(rawBlocks, entityMap);\n};\n\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\n  var rawEntityMap = rawState.entityMap;\n\n  var entityMap = {};\n\n  // TODO: Update this once we completely remove DraftEntity\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\n        type = _rawEntityMap$rawEnti.type,\n        mutability = _rawEntityMap$rawEnti.mutability,\n        data = _rawEntityMap$rawEnti.data;\n\n    // get the key reference to created entity\n\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\n  });\n\n  return entityMap;\n};\n\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;\n\n  // decode entities\n  var entityMap = decodeRawEntityMap(rawState);\n\n  // decode blockMap\n  var blockMap = decodeRawBlocks(rawState, entityMap);\n\n  // create initial selection\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\n\n  return new ContentState({\n    blockMap: blockMap,\n    entityMap: entityMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\n\nmodule.exports = convertFromRawToDraftState;"]},"metadata":{},"sourceType":"script"}