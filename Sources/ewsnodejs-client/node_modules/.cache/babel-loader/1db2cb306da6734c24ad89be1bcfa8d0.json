{"ast":null,"code":"import { Node } from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n} // function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\n\n\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n} // This function works analogously to nextLeft.\n\n\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n} // Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\n\n\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n} // All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\n\n\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n} // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\n\n\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n\n  this.a = this; // ancestor\n\n  this.z = 0; // prelim\n\n  this.m = 0; // mod\n\n  this.c = 0; // change\n\n  this.s = 0; // shift\n\n  this.t = null; // thread\n\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n} // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n\n\nexport default function () {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root); // Compute the layout using Buchheim et al.’s algorithm.\n\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.\n\n    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n        var left = root,\n            right = root,\n            bottom = root;\n        root.eachBefore(function (node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var s = left === right ? 1 : separation(left, right) / 2,\n            tx = s - left.x,\n            kx = dx / (right.x + s + tx),\n            ky = dy / (bottom.depth || 1);\n        root.eachBefore(function (node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n    return root;\n  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n\n\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  } // Computes all real x-coordinates by summing up the modifiers recursively.\n\n\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  } // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n\n\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function (x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];\n  };\n\n  tree.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;\n  };\n\n  return tree;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-hierarchy/src/tree.js"],"names":["Node","defaultSeparation","a","b","parent","nextLeft","v","children","t","nextRight","length","moveSubtree","wm","wp","shift","change","i","c","s","z","m","executeShifts","w","nextAncestor","vim","ancestor","TreeNode","node","_","A","prototype","Object","create","treeRoot","root","tree","nodes","child","n","pop","Array","push","separation","dx","dy","nodeSize","eachAfter","firstWalk","eachBefore","secondWalk","sizeNode","left","right","bottom","x","depth","tx","kx","ky","y","siblings","midpoint","apportion","vip","vop","vom","sip","sop","sim","som","arguments","size"],"mappings":"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","sourcesContent":["import {Node} from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n"]},"metadata":{},"sourceType":"module"}