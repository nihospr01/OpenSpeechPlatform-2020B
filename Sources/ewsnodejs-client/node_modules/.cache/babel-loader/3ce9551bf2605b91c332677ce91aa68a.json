{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","length","newBlock","merge","slice","characterList","data","getData","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","type","getType","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"]},"metadata":{},"sourceType":"script"}