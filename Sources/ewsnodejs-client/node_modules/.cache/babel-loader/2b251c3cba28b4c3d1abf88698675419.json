{"ast":null,"code":"import { createBorderEdge } from \"./Edge\";\nimport { cells, edges, epsilon } from \"./Diagram\";\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n\n      for (j = 0; j < m; ++j) {\n        index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      }\n\n      index.sort(function (i, j) {\n        return array[j] - array[i];\n      });\n\n      for (j = 0; j < m; ++j) {\n        array[j] = halfedges[index[j]];\n      }\n\n      for (j = 0; j < m; ++j) {\n        halfedges[j] = array[j];\n      }\n    }\n  }\n}\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length; // Remove any dangling clipped edges.\n\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      } // Insert any border edges as necessary.\n\n\n      iHalfedge = 0, nHalfedges = halfedges.length;\n\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1] : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0] : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  } // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n\n\n  if (cover) {\n    var dx,\n        dy,\n        d2,\n        dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0],\n          v01 = [x0, y1],\n          v11 = [x1, y1],\n          v10 = [x1, y0];\n      cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);\n    }\n  } // Lastly delete any cells with no edges; these were entirely clipped.\n\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/opt/osp/ewsnodejs-client/node_modules/d3-voronoi/src/Cell.js"],"names":["createBorderEdge","cells","edges","epsilon","createCell","site","index","halfedges","cellHalfedgeAngle","cell","edge","va","left","vb","right","Math","atan2","cellHalfedgeStart","cellHalfedgeEnd","sortCellHalfedges","i","n","length","j","m","Array","array","sort","clipCells","x0","y0","x1","y1","nCells","iCell","iHalfedge","nHalfedges","start","startX","startY","end","endX","endY","cover","splice","abs","push","dx","dy","d2","dc","Infinity","v00","v01","v11","v10"],"mappings":"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","sourcesContent":["import {createBorderEdge} from \"./Edge\";\nimport {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}