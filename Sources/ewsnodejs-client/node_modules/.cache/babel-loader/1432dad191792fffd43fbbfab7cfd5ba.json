{"ast":null,"code":"function defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n\n  while (children = node.children) {\n    node = children[0];\n  }\n\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n\n  while (children = node.children) {\n    node = children[children.length - 1];\n  }\n\n  return node;\n}\n\nexport default function () {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0; // First walk, computing the initial x & y values.\n\n    root.eachAfter(function (node) {\n      var children = node.children;\n\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2; // Second walk, normalizing x & y to the desired size.\n\n    return root.eachAfter(nodeSize ? function (node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function (node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function (x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];\n  };\n\n  cluster.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;\n  };\n\n  return cluster;\n}","map":{"version":3,"sources":["/opt/OpenSpeechPlatform-UCSD/Software/ewsnodejs-client/node_modules/d3-hierarchy/src/cluster.js"],"names":["defaultSeparation","a","b","parent","meanX","children","reduce","meanXReduce","length","x","c","maxY","maxYReduce","y","Math","max","leafLeft","node","leafRight","separation","dx","dy","nodeSize","cluster","root","previousNode","eachAfter","left","right","x0","x1","arguments","size"],"mappings":"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","sourcesContent":["function defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n}\n"]},"metadata":{},"sourceType":"module"}